Index: uno project/src/model/GameModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package model;\r\n\r\nimport java.util.*;\r\nimport controller.GameModelListener;\r\nimport controller.GameState;\r\n\r\n/**\r\n * Core model for the UNO game\r\n * manages game state, rules, and notifies listeners of changes.\r\n * this class has no UI or I/O dependencies, all interactions happen through\r\n * the controller.GameModelListener observer pattern\r\n * \r\n * @author Bhagya Patel, 101324150\r\n * @author Faris Hassan, 101300683\r\n * @author Nicky Fang, 101304731\r\n * @version 3.0\r\n */\r\n\r\npublic class GameModel {\r\n\r\n    private List<Player> players;\r\n    private List<Card> discardPile;\r\n    private Deck deck;\r\n    private int currentPlayerIndex;\r\n    private boolean isClockwise;\r\n    private List<GameModelListener> listeners;\r\n    private static final int TARGET_SCORE = 500;\r\n    private static final int INITIAL_HAND_SIZE = 7;\r\n    private boolean currentTurnTaken = false;\r\n    private Card.Side currentSide = Card.Side.LIGHT;  // Track which side is active\r\n\r\n    /**\r\n     * Creates a new GameModel with specified player count (all human players)\r\n     * @param playerCount Number of players (2-4)\r\n     */\r\n    public GameModel(int playerCount) {\r\n        this(playerCount, new boolean[playerCount] , AIPlayer.DifficultyLevel.MEDIUM); // All false = all human\r\n    }\r\n\r\n    /**\r\n     * Creates a new model.GameModel with specified player names.\r\n     * initializes the deck, discard pile. and sets up the game state.\r\n     *\r\n     * @param playerCount List of player names (must be 2-4 players)\r\n     * @throws IllegalArgumentException if player count is not between 2 and 4\r\n     */\r\n    public GameModel(int playerCount, boolean[] isAI, AIPlayer.DifficultyLevel difficultyLevel) {\r\n        if (playerCount == 0 || playerCount < 2 || playerCount > 4) {\r\n            throw new IllegalArgumentException(\"Game requires 2-4 players\");\r\n        }\r\n\r\n        if (isAI != null && isAI.length != playerCount) {\r\n            throw new IllegalArgumentException(\"isAI array must match player count\");\r\n        }\r\n\r\n        this.players = new ArrayList<>();\r\n        for (int i = 0; i < playerCount; i++) {\r\n            Player player;\r\n            if (isAI != null && isAI[i]) {\r\n                // create AI player with medium difficulty\r\n                player = new AIPlayer(\"AI Player \" + (i + 1), difficultyLevel);\r\n            } else {\r\n                player = new Player(\"Player \" + (i + 1));\r\n            }\r\n            this.players.add(player);\r\n        }\r\n\r\n        this.deck = new Deck();\r\n        this.discardPile = new ArrayList<>();\r\n        this.currentPlayerIndex = 0;\r\n        this.isClockwise = true;\r\n        this.listeners = new ArrayList<>();\r\n    }\r\n\r\n    /**\r\n     * Starts a new game by dealing cards and setting up the initial discard pile.\r\n     * Fires onGameInitialized event to all listeners\r\n     */\r\n    public void startGame() {\r\n        // Deal initial cards to each player\r\n        for (Player player : players) {\r\n            for (int i = 0; i < INITIAL_HAND_SIZE; i++) {\r\n                Card card = deck.drawCard();\r\n                if (card != null) {\r\n                    player.drawCard(card);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Place first card on discard pile (avoid starting with special cards)\r\n        Card firstCard = deck.drawCard();\r\n        while (firstCard != null && isSpecialCard(firstCard)) {\r\n            deck.drawCard(); // Put it back somehow, for simplicity just draw another\r\n            firstCard = deck.drawCard();\r\n        }\r\n\r\n        if (firstCard != null) {\r\n            discardPile.add(firstCard);\r\n        }\r\n\r\n        fireModelInit();\r\n    }\r\n\r\n    /**\r\n     * Plays a card from the current player's hand.\r\n     * Handles wild card color selection and special card effects.\r\n     *\r\n     * @param player      The player playing the card (unused in this simplified version)\r\n     * @param handIndex   Index of the card in the current player's hand\r\n     * @param chosenColor Color chosen for wild cards (null for non-wild cards)\r\n     */\r\n    public void playCard(Player player, int handIndex, Card.Color chosenColor) {\r\n        Player currentPlayer = players.get(currentPlayerIndex);\r\n\r\n        if (handIndex < 0 || handIndex >= currentPlayer.getHandSize()) {\r\n            fireError(\"Invalid card index: \" + handIndex);\r\n            return;\r\n        }\r\n\r\n        Card playedCard = currentPlayer.getHand().get(handIndex);\r\n\r\n        // Validate the card can be played\r\n        if (!isCardPlayable(playedCard)) {\r\n            fireError(\"Cannot play \" + playedCard + \" on \" + getTopDiscardCard());\r\n            return;\r\n        }\r\n\r\n        // Remove card from hand and add to discard pile\r\n        currentPlayer.getHand().remove(handIndex);\r\n        discardPile.add(playedCard);\r\n\r\n        // Handle wild card color choice\r\n        if (playedCard.getColor() == Card.Color.WILD && chosenColor != null) {\r\n            playedCard.setColor(chosenColor);\r\n        }\r\n\r\n        // Handle Wild Draw Color\r\n        if (playedCard.getValue() == Card.Value.WILD_DRAW_COLOR && chosenColor != null) {\r\n            playedCard.setColor(chosenColor);\r\n        }\r\n\r\n        fireStateUpdated();\r\n\r\n        // Check for round winner\r\n        if (currentPlayer.getHandSize() == 0) {\r\n            handleRoundWin(currentPlayerIndex);\r\n            return;\r\n        }\r\n\r\n        // Handle special card effects\r\n        if (playedCard.getValue() != Card.Value.SKIP &&\r\n                playedCard.getValue() != Card.Value.DRAW_ONE &&\r\n                playedCard.getValue() != Card.Value.WILD_DRAW_TWO &&\r\n                playedCard.getValue() != Card.Value.DRAW_FIVE &&\r\n                playedCard.getValue() != Card.Value.WILD_DRAW_COLOR &&\r\n                !(playedCard.getValue() == Card.Value.REVERSE && players.size() == 2)) {\r\n            currentTurnTaken = true;\r\n        }\r\n        fireStateUpdated();\r\n    }\r\n\r\n    /**\r\n     * Current player draws a card from the deck\r\n     *\r\n     * @return The drawn card, or null if deck is empty\r\n     */\r\n    public Card drawCard() {\r\n        Player currentPlayer = players.get(currentPlayerIndex);\r\n\r\n        Card drawnCard = deck.drawCard();\r\n\r\n        if (drawnCard != null) {\r\n            currentPlayer.drawCard(drawnCard);\r\n            currentTurnTaken = !isCardPlayable(drawnCard);\r\n            fireStateUpdated();\r\n            return drawnCard;\r\n        } else {\r\n            fireError(\"model.Deck is empty!\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ends the current player's turn and advances to the next player.\r\n     */\r\n    public void endTurn() {\r\n        advanceToNextPlayer();\r\n        currentTurnTaken = false;\r\n        fireTurnAdvanced(players.get(currentPlayerIndex));\r\n    }\r\n\r\n    /**\r\n     * Calculates and awards points when a player wins a round.\r\n     * The winner gets points equal to the sum of all cards in opponents' hands.\r\n     *\r\n     * @param winnerIndex The index of the winning player\r\n     * @return The total points awarded\r\n     */\r\n    public int calculateRoundScore(int winnerIndex) {\r\n        Player winner = players.get(winnerIndex);\r\n        int totalPoints = 0;\r\n\r\n        // Calculate points from all opponents' hands\r\n        for (int i = 0; i < players.size(); i++) {\r\n            if (i != winnerIndex) {\r\n                Player opponent = players.get(i);\r\n                int handValue = opponent.calculateHandValue();\r\n                totalPoints += handValue;\r\n            }\r\n        }\r\n\r\n        winner.addScore(totalPoints);\r\n        return totalPoints;\r\n    }\r\n\r\n    /**\r\n     * Checks if any player has reached the target score to win the game.\r\n     *\r\n     * @param targetScore The score needed to win the game (typically 500)\r\n     * @return The winning player, or null if no winner yet\r\n     */\r\n    public Player checkForGameWinner(int targetScore) {\r\n        for (Player player : players) {\r\n            if (player.getScore() >= targetScore) {\r\n                return player;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adds a listener to receive game events.\r\n     *\r\n     * @param l The listener to add\r\n     */\r\n    public void addListener(GameModelListener l) {\r\n        if (l != null && !listeners.contains(l)) {\r\n            listeners.add(l);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a listener from receiving game events.\r\n     *\r\n     * @param l The listener to remove\r\n     */\r\n    public void removeListener(GameModelListener l) {\r\n\r\n        listeners.remove(l);\r\n    }\r\n\r\n    //HELPER METHODS\r\n\r\n    /**\r\n     * Gets the top card of the discard pile.\r\n     *\r\n     * @return The top card, or null if discard pile is empty\r\n     */\r\n    private Card getTopDiscardCard() {\r\n        if (discardPile.isEmpty()) {\r\n            return null;\r\n        }\r\n        return discardPile.get(discardPile.size() - 1);\r\n    }\r\n\r\n    /**\r\n     * Gets indices of playable cards in current player's hand.\r\n     *\r\n     * @return List of indices representing playable cards\r\n     */\r\n    private List<Integer> getPlayableIndices() {\r\n        Player currentPlayer = players.get(currentPlayerIndex);\r\n        List<Integer> playableIndices = new ArrayList<>();\r\n        Card topCard = getTopDiscardCard();\r\n\r\n        if (topCard == null) {\r\n            // All cards playable if no top card\r\n            for (int i = 0; i < currentPlayer.getHandSize(); i++) {\r\n                playableIndices.add(i);\r\n            }\r\n            return playableIndices;\r\n        }\r\n\r\n        for (int i = 0; i < currentPlayer.getHandSize(); i++) {\r\n            Card card = currentPlayer.getHand().get(i);\r\n            if (isCardPlayable(card)) {\r\n                playableIndices.add(i);\r\n            }\r\n        }\r\n\r\n        return playableIndices;\r\n    }\r\n\r\n    /**\r\n     * Checks if a card can be played on the current discard pile.\r\n     *\r\n     * @param card The card to check\r\n     * @return true if the card is playable, false otherwise\r\n     */\r\n    private boolean isCardPlayable(Card card) {\r\n        Card topCard = getTopDiscardCard();\r\n\r\n        if (topCard == null) {\r\n            return true;\r\n        }\r\n\r\n        // Wild cards can always be played\r\n        if (card.getColor() == Card.Color.WILD) {\r\n            return true;\r\n        }\r\n\r\n        // Same color\r\n        if (card.getColor() == topCard.getColor()) {\r\n            return true;\r\n        }\r\n\r\n        // Same value\r\n        if (card.getValue() == topCard.getValue()) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if a card is a special action card.\r\n     *\r\n     * @param card The card to check\r\n     * @return true if the card is special, false otherwise\r\n     */\r\n    private boolean isSpecialCard(Card card) {\r\n        Card.Value value = card.getValue();\r\n        return value == Card.Value.SKIP ||\r\n                value == Card.Value.REVERSE ||\r\n                value == Card.Value.DRAW_ONE ||\r\n                value == Card.Value.WILD ||\r\n                value == Card.Value.WILD_DRAW_TWO ||\r\n                value == Card.Value.FLIP ||\r\n                value == Card.Value.DRAW_FIVE ||\r\n                value == Card.Value.SKIP_EVERYONE ||\r\n                value == Card.Value.WILD_DRAW_COLOR;\r\n    }\r\n\r\n    /**\r\n     * Handles the effects of special cards.\r\n     *\r\n     * @param playedCard The special card that was played\r\n     */\r\n    private void handleSpecialCard(Card playedCard) {\r\n        switch (playedCard.getValue()) {\r\n            case SKIP:\r\n                advanceToNextPlayer();\r\n                currentTurnTaken = false;\r\n                fireTurnAdvanced(players.get(currentPlayerIndex));\r\n                break;\r\n\r\n            case REVERSE:\r\n                isClockwise = !isClockwise;\r\n                if (players.size() == 2) {\r\n                    // In 2-player game, reverse acts like skip\r\n                    advanceToNextPlayer();\r\n                    currentTurnTaken = false;\r\n                    fireTurnAdvanced(players.get(currentPlayerIndex));\r\n                }\r\n                break;\r\n\r\n            case DRAW_ONE:\r\n                advanceToNextPlayer();\r\n                Player drawOneTarget = players.get(currentPlayerIndex);\r\n                Card drawn = deck.drawCard();\r\n                if (drawn != null) {\r\n                    drawOneTarget.drawCard(drawn);\r\n                }\r\n                currentTurnTaken = false;\r\n                fireTurnAdvanced(players.get(currentPlayerIndex));\r\n                break;\r\n\r\n            case WILD_DRAW_TWO:\r\n                advanceToNextPlayer();\r\n                Player drawTwoTarget = players.get(currentPlayerIndex);\r\n                for (int i = 0; i < 2; i++) {\r\n                    Card drawnCard = deck.drawCard();\r\n                    if (drawnCard != null) {\r\n                        drawTwoTarget.drawCard(drawnCard);\r\n                    }\r\n                }\r\n                currentTurnTaken = false;\r\n                fireTurnAdvanced(players.get(currentPlayerIndex));\r\n                break;\r\n\r\n            case WILD:\r\n                // Color already set in playCard method\r\n                break;\r\n\r\n            case FLIP:\r\n                handleFlipCard();\r\n                break;\r\n\r\n            case DRAW_FIVE:\r\n                handleDrawFive();\r\n                currentTurnTaken = false;\r\n                fireTurnAdvanced(players.get(currentPlayerIndex));\r\n                break;\r\n\r\n            case SKIP_EVERYONE:\r\n                handleSkipEveryone();\r\n                break;\r\n\r\n            case WILD_DRAW_COLOR:\r\n                handleWildDrawColor(playedCard);\r\n                currentTurnTaken = false;\r\n                fireTurnAdvanced(players.get(currentPlayerIndex));\r\n                break;\r\n\r\n            default:\r\n                // Regular number card, no special effect\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles the FLIP card effect\r\n     * Flips all cards in the game to their opposite side.\r\n     */\r\n    private void handleFlipCard() {\r\n        currentSide = (currentSide == Card.Side.LIGHT) ? Card.Side.DARK : Card.Side.LIGHT;\r\n\r\n        // Loop through all cards in all players' hands\r\n        for (Player player : players) {\r\n            player.flipHand();\r\n        }\r\n\r\n        // Flip all cards in discard pile\r\n        for (Card card : discardPile) {\r\n            card.flip();\r\n        }\r\n\r\n        // Flip all cards in deck\r\n        deck.flipAllCards();\r\n\r\n        fireStateUpdated();\r\n    }\r\n\r\n    /**\r\n     * Handles the DRAW FIVE card effect.\r\n     * Next player draws 5 cards and skips their turn.\r\n     */\r\n    private void handleDrawFive() {\r\n        advanceToNextPlayer();\r\n        Player target = players.get(currentPlayerIndex);\r\n\r\n        // Draw 5 cards\r\n        for (int i = 0; i < 5; i++) {\r\n            Card drawnCard = deck.drawCard();\r\n            if (drawnCard != null) {\r\n                target.drawCard(drawnCard);\r\n            } else {\r\n                fireError(\"Deck exhausted during Draw Five\");\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles the SKIP EVERYONE card effect.\r\n     * All other players are skipped, current player gets another turn.\r\n     */\r\n    private void handleSkipEveryone() {\r\n        // Current player gets another turn, don't advance\r\n        // Skips all other players\r\n        // No action needed, turn stays with current player\r\n    }\r\n\r\n    /**\r\n     * Handles the WILD DRAW COLOR card effect.\r\n     * Next player draws cards until they get one of the chosen color.\r\n     *\r\n     * @param playedCard The Wild Draw Color card with chosen color\r\n     */\r\n    private void handleWildDrawColor(Card playedCard) {\r\n        advanceToNextPlayer();\r\n        Player target = players.get(currentPlayerIndex);\r\n        Card.Color targetColor = playedCard.getColor();\r\n\r\n        if (targetColor == Card.Color.WILD) {\r\n            fireError(\"Wild Draw Color requires a color choice\");\r\n            return;\r\n        }\r\n\r\n        // Draw cards until getting the target color\r\n        Card drawnCard;\r\n        int cardsDrawn = 0;\r\n        int maxCards = 20; // Safety limit to prevent infinite loop\r\n\r\n        do {\r\n            drawnCard = deck.drawCard();\r\n            if (drawnCard != null) {\r\n                target.drawCard(drawnCard);\r\n                cardsDrawn++;\r\n            } else {\r\n                fireError(\"Deck exhausted during Wild Draw Color\");\r\n                break;\r\n            }\r\n\r\n            if (cardsDrawn >= maxCards) {\r\n                fireError(\"Maximum cards drawn for Wild Draw Color\");\r\n                break;\r\n            }\r\n\r\n        } while (drawnCard != null && drawnCard.getColor() != targetColor);\r\n    }\r\n\r\n\r\n    \r\n    /**\r\n     * Advances the turn to the next player based on direction.\r\n     */\r\n    private void advanceToNextPlayer() {\r\n        if (isClockwise) {\r\n            currentPlayerIndex = (currentPlayerIndex + 1) % players.size();\r\n        } else {\r\n            currentPlayerIndex = (currentPlayerIndex - 1 + players.size()) % players.size();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handles round win scoring and checks for game winner.\r\n     * \r\n     * @param winnerIndex Index of the player who won the round\r\n     */\r\n    private void handleRoundWin(int winnerIndex) {\r\n        Player winner = players.get(winnerIndex);\r\n        int points = calculateRoundScore(winnerIndex);\r\n        \r\n        fireRoundWon(winner, points);\r\n        \r\n        // Check for game winner\r\n        Player gameWinner = checkForGameWinner(TARGET_SCORE);\r\n        if (gameWinner != null) {\r\n            fireGameWon(gameWinner);\r\n        }\r\n\r\n        newRound();\r\n    }\r\n\r\n    //EVENT FIRING METHODS\r\n    \r\n    /**\r\n     * Notifies all listeners that the game model has been initialized.\r\n     */\r\n    private void fireModelInit() {\r\n        GameState state = getState();\r\n        for (GameModelListener listener : listeners) {\r\n            listener.onModelInit(state);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Notifies all listeners that the game state has been updated.\r\n     */\r\n    private void fireStateUpdated() {\r\n        GameState state = getState();\r\n        for (GameModelListener listener : listeners) {\r\n            listener.onStateUpdated(state);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Notifies all listeners that the turn has advanced to the next player.\r\n     * \r\n     * @param current The player whose turn it now is\r\n     */\r\n    private void fireTurnAdvanced(Player current) {\r\n        GameState state = getState();\r\n        for (GameModelListener listener : listeners) {\r\n            listener.onTurnAdvanced(current, state);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Notifies all listeners that a player has won a round.\r\n     * \r\n     * @param winner The player who won the round\r\n     * @param points Points awarded to the winner\r\n     */\r\n    private void fireRoundWon(Player winner, int points) {\r\n        GameState state = getState();\r\n        for (GameModelListener listener : listeners) {\r\n            listener.onRoundWon(winner, points, state);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Notifies all listeners that a player has won the game.\r\n     * \r\n     * @param winner The player who won the game\r\n     */\r\n    private void fireGameWon(Player winner) {\r\n        GameState state = getState();\r\n        for (GameModelListener listener : listeners) {\r\n            listener.onGameWon(winner, state);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Notifies all listeners of an error condition.\r\n     * \r\n     * @param msg Error message\r\n     */\r\n    private void fireError(String msg) {\r\n        for (GameModelListener listener : listeners) {\r\n            listener.onError(msg);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    public GameState getState()\r\n    {\r\n        GameState state = new GameState();\r\n        state.players = new ArrayList<>(players);\r\n        state.currentPlayer = players.get(currentPlayerIndex);\r\n        state.topDiscard = getTopDiscardCard();\r\n        state.deckSize = deck.size();\r\n        state.playableIndices = getPlayableIndices();\r\n        state.clockwise = isClockwise;\r\n        state.turnTaken = currentTurnTaken;\r\n        state.currentSide = currentSide;  // Include current side\r\n        return state;\r\n    }\r\n\r\n    public List<GameModelListener> getListeners() {\r\n        return listeners;\r\n    }\r\n\r\n    public void newRound() {\r\n        // Clear all hands\r\n        for (Player p : players) {\r\n            p.getHand().clear();\r\n        }\r\n\r\n        // Reset deck and discard pile\r\n        deck = new Deck();\r\n        discardPile.clear();\r\n        discardPile.add(deck.drawCard());  // new top card\r\n\r\n        // Deal 7 cards to each player\r\n        for (Player p : players) {\r\n            for (int i = 0; i < 7; i++) {\r\n                Card c = deck.drawCard();\r\n                if (c != null) p.drawCard(c);\r\n            }\r\n        }\r\n\r\n        // Reset turn state\r\n        currentPlayerIndex = 0;  // or rotate starting player\r\n        isClockwise = true;\r\n        currentTurnTaken = false;\r\n        currentSide = Card.Side.LIGHT;\r\n\r\n        fireStateUpdated();\r\n    }\r\n\r\n    /**\r\n     * Processes an AI player turn\r\n     * called after advancing to AI player\r\n     */\r\n    public void processAITurn() {\r\n        Player currentPlayer = players.get(currentPlayerIndex);\r\n\r\n        //check if player is of AIPlayer object (inheritance)\r\n        if (!(currentPlayer instanceof AIPlayer)) {\r\n            return;\r\n        }\r\n\r\n        AIPlayer aiPlayer = (AIPlayer) currentPlayer;\r\n\r\n        // delay, remove this for testing\r\n        javax.swing.Timer timer = new javax.swing.Timer(3000, e -> {\r\n            GameState state = getState();\r\n            int cardIndex = aiPlayer.selectCardToPlay(state);\r\n\r\n            if (cardIndex == -1) {\r\n                Card drawnCard = drawCard();\r\n                if (drawnCard != null && isCardPlayable(drawnCard)) {\r\n                    int drawnCardIndex = aiPlayer.getHandSize() - 1;\r\n                    handleAICardPlay(aiPlayer, drawnCardIndex);\r\n                } else {\r\n                    endTurn();\r\n                }\r\n            } else {\r\n                handleAICardPlay(aiPlayer, cardIndex);\r\n            }\r\n        });\r\n        timer.setRepeats(false); // Only fire once\r\n        timer.start();\r\n    }\r\n\r\n    /**\r\n     * Handles AI playing a card, including wild color selection\r\n     */\r\n    private void handleAICardPlay(AIPlayer aiPlayer, int cardIndex) {\r\n        Card playedCard = aiPlayer.getHand().get(cardIndex);\r\n        Card.Color chosenColor = null;\r\n\r\n        // AI chooses color for wild cards\r\n        if (playedCard.getColor() == Card.Color.WILD) {\r\n            if (playedCard.getValue() == Card.Value.WILD ||\r\n                    playedCard.getValue() == Card.Value.WILD_DRAW_TWO) {\r\n                chosenColor = aiPlayer.chooseWildColor();\r\n            } else if (playedCard.getValue() == Card.Value.WILD_DRAW_COLOR) {\r\n                chosenColor = aiPlayer.chooseWildDrawColor();\r\n            }\r\n        }\r\n\r\n        // Play card\r\n        playCard(aiPlayer, cardIndex, chosenColor);\r\n\r\n        // Check if game should continue (not ended by round/game win)\r\n        if (aiPlayer.getHandSize() > 0) {\r\n            // For Skip Everyone card, AI gets another turn\r\n            if (playedCard.getValue() == Card.Value.SKIP_EVERYONE) {\r\n                currentTurnTaken = false;\r\n                fireStateUpdated();\r\n                // Process another AI turn immediately\r\n                processAITurn();\r\n            } else {\r\n                endTurn();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check if current player is AI and processes turn\r\n     */\r\n    public void checkAndProcessAITurn() {\r\n        Player currentPlayer = players.get(currentPlayerIndex);\r\n        if (currentPlayer instanceof AIPlayer) {\r\n            processAITurn();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/model/GameModel.java b/uno project/src/model/GameModel.java
--- a/uno project/src/model/GameModel.java	(revision 49963df5e0818cc34f981de6f065167c53e7528f)
+++ b/uno project/src/model/GameModel.java	(date 1764809967753)
@@ -28,6 +28,8 @@
     private static final int INITIAL_HAND_SIZE = 7;
     private boolean currentTurnTaken = false;
     private Card.Side currentSide = Card.Side.LIGHT;  // Track which side is active
+    private Stack<GameState> undoStack = new Stack<>();
+    private Stack<GameState> redoStack = new Stack<>();
 
     /**
      * Creates a new GameModel with specified player count (all human players)
@@ -70,6 +72,8 @@
         this.currentPlayerIndex = 0;
         this.isClockwise = true;
         this.listeners = new ArrayList<>();
+        this.undoStack = new Stack<GameState>();
+        this.redoStack = new Stack<GameState>();
     }
 
     /**
@@ -700,6 +704,7 @@
      * Handles AI playing a card, including wild color selection
      */
     private void handleAICardPlay(AIPlayer aiPlayer, int cardIndex) {
+        saveStateOnMove();
         Card playedCard = aiPlayer.getHand().get(cardIndex);
         Card.Color chosenColor = null;
 
@@ -739,4 +744,31 @@
             processAITurn();
         }
     }
+
+    private void saveStateOnMove() {
+        undoStack.push(getState());
+        redoStack.clear();
+    }
+
+    public void undo() {
+        if (!undoStack.isEmpty()) {
+            redoStack.push(getState());
+            GameState prev = undoStack.pop();
+            restoreState(prev);
+            fireStateUpdated();
+        }
+    }
+
+    public void redo() {
+        if (!redoStack.isEmpty()) {
+            undoStack.push(getState());
+            GameState next = redoStack.pop();
+            restoreState(next);
+            fireStateUpdated();
+        }
+    }
+
+    private void restoreState(GameState state) {
+
+    }
 }
\ No newline at end of file
Index: uno project/tests/AIPlayerTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import model.Card;\r\nimport model.AIPlayer;\r\nimport model.Player;\r\nimport controller.GameState;\r\nimport model.GameModel;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * JUnit tests for AIPlayer difficulty levels and strategy implementation.\r\n * Tests card selection logic, wild color selection, and polymorphic behavior.\r\n *\r\n * @author Bhagya Patel, 101324150\r\n * @version 3.0\r\n */\r\npublic class AIPlayerTest {\r\n\r\n    private AIPlayer easyAI;\r\n    private AIPlayer mediumAI;\r\n    private AIPlayer hardAI;\r\n    private GameModel gameModel;\r\n    private GameState gameState;\r\n\r\n    @BeforeEach\r\n    public void setUp() {\r\n        easyAI = new AIPlayer(\"Easy AI\", AIPlayer.DifficultyLevel.EASY);\r\n        mediumAI = new AIPlayer(\"Medium AI\", AIPlayer.DifficultyLevel.MEDIUM);\r\n        hardAI = new AIPlayer(\"Hard AI\", AIPlayer.DifficultyLevel.HARD);\r\n\r\n        // Create game with 2 human + 1 AI\r\n        boolean[] isAI = {false, false, true};\r\n        gameModel = new GameModel(3, isAI);\r\n        gameModel.startGame();\r\n        gameState = gameModel.getState();\r\n    }\r\n\r\n    // Test: AIPlayer Constructors\r\n\r\n    @Test\r\n    public void testAIPlayerConstructorWithDifficulty() {\r\n        assertEquals(\"Easy AI\", easyAI.getName());\r\n        assertEquals(AIPlayer.DifficultyLevel.EASY, easyAI.getDifficultyLevel());\r\n    }\r\n\r\n    @Test\r\n    public void testAIPlayerDefaultDifficulty() {\r\n        AIPlayer defaultAI = new AIPlayer(\"Default AI\");\r\n        assertEquals(AIPlayer.DifficultyLevel.MEDIUM, defaultAI.getDifficultyLevel());\r\n    }\r\n\r\n    @Test\r\n    public void testAIPlayerIsAI() {\r\n        assertTrue(easyAI.isAI());\r\n        assertTrue(mediumAI.isAI());\r\n        assertTrue(hardAI.isAI());\r\n\r\n        // Compare with regular player\r\n        Player humanPlayer = new Player(\"Human\");\r\n        assertFalse(humanPlayer.isAI());\r\n    }\r\n\r\n    // Test: EASY Difficulty (Random Selection)\r\n\r\n    @Test\r\n    public void testEasyAIDifficultyReturnsValidCard() {\r\n        // Setup: Add multiple playable cards\r\n        Player player = easyAI;\r\n        player.drawCard(new Card(Card.Color.RED, Card.Value.ONE));\r\n        player.drawCard(new Card(Card.Color.RED, Card.Value.TWO));\r\n        player.drawCard(new Card(Card.Color.RED, Card.Value.THREE));\r\n\r\n        GameState state = gameModel.getState();\r\n        int selectedIndex = easyAI.selectCardToPlay(state);\r\n\r\n        // Should return -1 (draw) or valid playable index\r\n        assertTrue(selectedIndex == -1 || state.playableIndices.contains(selectedIndex),\r\n                \"Easy AI should select from playable indices or draw\");\r\n    }\r\n\r\n    @Test\r\n    public void testEasyAIRandomness() {\r\n        // Fill hand with same color cards (all playable)\r\n        easyAI.drawCard(new Card(Card.Color.BLUE, Card.Value.ONE));\r\n        easyAI.drawCard(new Card(Card.Color.BLUE, Card.Value.TWO));\r\n        easyAI.drawCard(new Card(Card.Color.BLUE, Card.Value.THREE));\r\n        easyAI.drawCard(new Card(Card.Color.BLUE, Card.Value.FOUR));\r\n\r\n        GameState state = gameModel.getState();\r\n\r\n        // Run multiple times and collect selections\r\n        List<Integer> selections = new ArrayList<>();\r\n        for (int i = 0; i < 10; i++) {\r\n            int index = easyAI.selectCardToPlay(state);\r\n            if (index != -1) {\r\n                selections.add(index);\r\n            }\r\n        }\r\n\r\n        // Should have variety (not all same card)\r\n        assertTrue(selections.size() > 0, \"Easy AI should make selections\");\r\n    }\r\n\r\n    @Test\r\n    public void testEasyAIDrawsWhenNoCards() {\r\n        // Empty hand with no playable cards\r\n        GameState emptyState = new GameState();\r\n        emptyState.playableIndices = new ArrayList<>();\r\n\r\n        int result = easyAI.selectCardToPlay(emptyState);\r\n        assertEquals(-1, result, \"Easy AI should return -1 (draw) when no playable cards\");\r\n    }\r\n\r\n    // Test: MEDIUM Difficulty (Priority Strategy)\r\n\r\n    @Test\r\n    public void testMediumAIPrioritizesSpecialCards() {\r\n        // Hand with both number and special cards\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.ONE));\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.SKIP)); // Special\r\n\r\n        GameState state = gameModel.getState();\r\n        int selectedIndex = mediumAI.selectCardToPlay(state);\r\n\r\n        // Should select from playable (could be skip if playable)\r\n        assertTrue(selectedIndex == -1 || state.playableIndices.contains(selectedIndex));\r\n    }\r\n\r\n    @Test\r\n    public void testMediumAIPrioritizesColorMatch() {\r\n        // Setup: top card is RED 5\r\n        Card topCard = new Card(Card.Color.RED, Card.Value.FIVE);\r\n\r\n        // Hand with color match and non-matching\r\n        mediumAI.drawCard(new Card(Card.Color.BLUE, Card.Value.ONE));\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.THREE)); // Color match\r\n\r\n        GameState state = gameModel.getState();\r\n        int selectedIndex = mediumAI.selectCardToPlay(state);\r\n\r\n        // Should prefer color match\r\n        assertTrue(selectedIndex == -1 || state.playableIndices.contains(selectedIndex));\r\n    }\r\n\r\n    @Test\r\n    public void testMediumAIPrioritizesHighValue() {\r\n        // Hand with various values\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.ONE)); // 1 point\r\n        mediumAI.drawCard(new Card(Card.Color.BLUE, Card.Value.TWO)); // 2 points\r\n        mediumAI.drawCard(new Card(Card.Color.GREEN, Card.Value.SKIP)); // 20 points\r\n\r\n        GameState state = gameModel.getState();\r\n        int selectedIndex = mediumAI.selectCardToPlay(state);\r\n\r\n        assertTrue(selectedIndex == -1 || state.playableIndices.contains(selectedIndex));\r\n    }\r\n\r\n    // Test: HARD Difficulty (Advanced Strategy)\r\n\r\n    @Test\r\n    public void testHardAIDetectsThreat() {\r\n        // Setup: Next player has 2 cards (threat!)\r\n        gameModel.startGame();\r\n        Player nextPlayer = gameModel.getState().players.get(1);\r\n\r\n        // Remove most cards from next player (simulate threat)\r\n        while (nextPlayer.getHandSize() > 2) {\r\n            nextPlayer.getHand().remove(0);\r\n        }\r\n\r\n        // AI hand with disruptive cards\r\n        hardAI.drawCard(new Card(Card.Color.WILD, Card.Value.WILD_DRAW_TWO));\r\n\r\n        GameState state = gameModel.getState();\r\n        int selectedIndex = hardAI.selectCardToPlay(state);\r\n\r\n        // Hard AI should try to disrupt (select disruptive card if playable)\r\n        assertTrue(selectedIndex == -1 || state.playableIndices.contains(selectedIndex));\r\n    }\r\n\r\n    @Test\r\n    public void testHardAIPreservesWildCards() {\r\n        // Hand with wild and non-wild playable\r\n        hardAI.drawCard(new Card(Card.Color.RED, Card.Value.FIVE)); // Non-wild\r\n        hardAI.drawCard(new Card(Card.Color.WILD, Card.Value.WILD)); // Wild\r\n\r\n        GameState state = gameModel.getState();\r\n        int selectedIndex = hardAI.selectCardToPlay(state);\r\n\r\n        // Hard AI should prefer non-wild if available\r\n        assertTrue(selectedIndex == -1 || state.playableIndices.contains(selectedIndex));\r\n    }\r\n\r\n    // Test: Wild Color Selection\r\n\r\n    @Test\r\n    public void testChooseWildColorReturnsValidColor() {\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.ONE));\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.TWO));\r\n        mediumAI.drawCard(new Card(Card.Color.BLUE, Card.Value.THREE));\r\n\r\n        Card.Color chosenColor = mediumAI.chooseWildColor();\r\n\r\n        assertNotNull(chosenColor);\r\n        assertNotEquals(Card.Color.WILD, chosenColor,\r\n                \"Should not choose WILD color\");\r\n        assertTrue(chosenColor == Card.Color.RED || chosenColor == Card.Color.BLUE ||\r\n                        chosenColor == Card.Color.GREEN || chosenColor == Card.Color.YELLOW,\r\n                \"Should choose valid light-side color\");\r\n    }\r\n\r\n    @Test\r\n    public void testChooseWildColorPrefersMostCommon() {\r\n        // Hand dominated by RED\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.ONE));\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.TWO));\r\n        mediumAI.drawCard(new Card(Card.Color.RED, Card.Value.THREE));\r\n        mediumAI.drawCard(new Card(Card.Color.BLUE, Card.Value.FOUR));\r\n\r\n        Card.Color chosenColor = mediumAI.chooseWildColor();\r\n\r\n        assertEquals(Card.Color.RED, chosenColor,\r\n                \"Should choose most common color (RED)\");\r\n    }\r\n\r\n    @Test\r\n    public void testChooseWildDrawColorReturnsValidDarkColor() {\r\n        mediumAI.drawCard(new Card(Card.Color.TEAL, Card.Value.ONE));\r\n        mediumAI.drawCard(new Card(Card.Color.PURPLE, Card.Value.TWO));\r\n\r\n        Card.Color chosenColor = mediumAI.chooseWildDrawColor();\r\n\r\n        assertNotNull(chosenColor);\r\n        assertTrue(chosenColor == Card.Color.TEAL || chosenColor == Card.Color.PURPLE ||\r\n                        chosenColor == Card.Color.PINK || chosenColor == Card.Color.ORANGE,\r\n                \"Should choose valid dark-side color\");\r\n    }\r\n\r\n    @Test\r\n    public void testChooseWildColorWhenHandEmpty() {\r\n        // Empty hand\r\n        Card.Color chosenColor = mediumAI.chooseWildColor();\r\n\r\n        assertNotNull(chosenColor, \"Should choose random color even with empty hand\");\r\n        assertTrue(chosenColor == Card.Color.RED || chosenColor == Card.Color.BLUE ||\r\n                chosenColor == Card.Color.GREEN || chosenColor == Card.Color.YELLOW);\r\n    }\r\n\r\n    // Test: Hand Operations (Inherited)\r\n\r\n    @Test\r\n    public void testAIPlayerHandManagement() {\r\n        assertEquals(0, hardAI.getHandSize());\r\n\r\n        Card card1 = new Card(Card.Color.RED, Card.Value.FIVE);\r\n        hardAI.drawCard(card1);\r\n\r\n        assertEquals(1, hardAI.getHandSize());\r\n        assertTrue(hardAI.getHand().contains(card1));\r\n    }\r\n\r\n    @Test\r\n    public void testAIPlayerHandValue() {\r\n        hardAI.drawCard(new Card(Card.Color.RED, Card.Value.FIVE)); // 5\r\n        hardAI.drawCard(new Card(Card.Color.BLUE, Card.Value.SKIP)); // 20\r\n\r\n        assertEquals(25, hardAI.calculateHandValue());\r\n    }\r\n\r\n    // Test: AI Turn Integration with GameModel\r\n\r\n    @Test\r\n    public void testGameModelDetectsAI() {\r\n        boolean[] isAI = {true, false};\r\n        GameModel gameWithAI = new GameModel(2, isAI);\r\n\r\n        Player player0 = gameWithAI.getState().players.get(0);\r\n        Player player1 = gameWithAI.getState().players.get(1);\r\n\r\n        assertTrue(player0.isAI(), \"Player 0 should be AI\");\r\n        assertFalse(player1.isAI(), \"Player 1 should be human\");\r\n    }\r\n\r\n    @Test\r\n    public void testAIPlayerIntegrationWithGameModel() {\r\n        gameModel.startGame();\r\n        GameState state = gameModel.getState();\r\n\r\n        // Advance to AI player\r\n        Player currentPlayer = state.currentPlayer;\r\n\r\n        // Should be able to call isAI() on any player\r\n        assertNotNull(currentPlayer.isAI());\r\n    }\r\n\r\n    // Test: Legal Move Guarantee\r\n\r\n    @Test\r\n    public void testAISelectsOnlyLegalMoves() {\r\n        gameModel.startGame();\r\n        GameState state = gameModel.getState();\r\n\r\n        for (int i = 0; i < 20; i++) {\r\n            int selectedIndex = mediumAI.selectCardToPlay(state);\r\n\r\n            if (selectedIndex != -1) {\r\n                assertTrue(state.playableIndices.contains(selectedIndex),\r\n                        \"AI must select from playable indices\");\r\n            }\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testAIDrawsWhenNoLegalMoves() {\r\n        GameState emptyState = new GameState();\r\n        emptyState.playableIndices = new ArrayList<>();\r\n\r\n        int result = easyAI.selectCardToPlay(emptyState);\r\n        assertEquals(-1, result, \"AI should return -1 to draw when no legal moves\");\r\n    }\r\n\r\n    // Test: Difficulty Levels Enum\r\n\r\n    @Test\r\n    public void testDifficultyLevelEnum() {\r\n        assertNotNull(AIPlayer.DifficultyLevel.EASY);\r\n        assertNotNull(AIPlayer.DifficultyLevel.MEDIUM);\r\n        assertNotNull(AIPlayer.DifficultyLevel.HARD);\r\n    }\r\n\r\n    @Test\r\n    public void testAIDifficultyAssignment() {\r\n        AIPlayer easy = new AIPlayer(\"Test\", AIPlayer.DifficultyLevel.EASY);\r\n        AIPlayer medium = new AIPlayer(\"Test\", AIPlayer.DifficultyLevel.MEDIUM);\r\n        AIPlayer hard = new AIPlayer(\"Test\", AIPlayer.DifficultyLevel.HARD);\r\n\r\n        assertEquals(AIPlayer.DifficultyLevel.EASY, easy.getDifficultyLevel());\r\n        assertEquals(AIPlayer.DifficultyLevel.MEDIUM, medium.getDifficultyLevel());\r\n        assertEquals(AIPlayer.DifficultyLevel.HARD, hard.getDifficultyLevel());\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/tests/AIPlayerTest.java b/uno project/tests/AIPlayerTest.java
--- a/uno project/tests/AIPlayerTest.java	(revision 49963df5e0818cc34f981de6f065167c53e7528f)
+++ b/uno project/tests/AIPlayerTest.java	(date 1764809617911)
@@ -33,7 +33,7 @@
 
         // Create game with 2 human + 1 AI
         boolean[] isAI = {false, false, true};
-        gameModel = new GameModel(3, isAI);
+        //gameModel = new GameModel(3, isAI);
         gameModel.startGame();
         gameState = gameModel.getState();
     }
@@ -275,7 +275,7 @@
     @Test
     public void testGameModelDetectsAI() {
         boolean[] isAI = {true, false};
-        GameModel gameWithAI = new GameModel(2, isAI);
+        GameModel gameWithAI = new GameModel(2, isAI, AIPlayer.DifficultyLevel.MEDIUM);
 
         Player player0 = gameWithAI.getState().players.get(0);
         Player player1 = gameWithAI.getState().players.get(1);
Index: uno project/src/controller/GameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controller;\r\n\r\nimport model.Card;\r\nimport model.GameModel;\r\nimport model.Player;\r\nimport view.GameView;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\n\r\n/**\r\n * COntroller for uno game implementing MVC pattern\r\n * Mediates between model.GameModel and view.GameView\r\n * Handles user input via ActionListener and updates the view via controller.GameModelListener\r\n *\r\n * @author Nicky Fang 101304731\r\n *\r\n * @author Bhagya Patel 101324150\r\n * @version 3.0\r\n * @brief added methods to support ai players\r\n *\r\n */\r\npublic class GameController implements ActionListener, GameModelListener {\r\n\r\n    //\r\n    private GameModel model;\r\n    private GameView view;\r\n\r\n    /**\r\n     *\r\n     * @param model The game model\r\n     * @param view The game view\r\n     */\r\n    public GameController(GameModel model, GameView view) {\r\n        this.model = model;\r\n        this.view = view;\r\n\r\n        //add this controller to the model\r\n\r\n        model.addListener(this);\r\n\r\n        //add this controller to the view\r\n        //view.bindController(this);\r\n    }\r\n\r\n    /**\r\n     * Handles button clicks and other actions from the view\r\n     * Sends commands to appropriate handler method\r\n     * @param e the event to be processed\r\n     */\r\n    @Override\r\n    public void actionPerformed(ActionEvent e) {\r\n        String command = e.getActionCommand();\r\n\r\n        try {\r\n            if (command.startsWith(\"PLAY:\"))\r\n            {\r\n                //extract card index from command\r\n                int cardIndex = Integer.parseInt(command.substring(5));\r\n                onPlayCard(cardIndex);\r\n            }\r\n            else if (command.equals(\"DRAW\"))\r\n            {\r\n                onDrawCard();\r\n            }\r\n            else if (command.equals(\"NEXT\"))\r\n            {\r\n                onEndTurn();\r\n            }\r\n            //this is only used during development in case a new command is added but not implemented here\r\n            else\r\n            {\r\n                view.showMessage(\"Unknown command: \" + command);\r\n            }\r\n        }\r\n\r\n        catch (Exception ex) {\r\n            view.showMessage(\"Error: \" + ex.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles playing card from current hand\r\n     * verifies card index before sending to model\r\n     * @param cardIndex\r\n     */\r\n    private void onPlayCard(int cardIndex) {\r\n\r\n        //get game state\r\n        GameState gameState = model.getState();\r\n        Player currentPlayer = gameState.currentPlayer;\r\n\r\n        //check card index\r\n        if (cardIndex < 0 || cardIndex >= currentPlayer.getHandSize()) {\r\n            view.showMessage(\"Invalid card index: \" + cardIndex);\r\n            return;\r\n        }\r\n\r\n        //check if car d playable\r\n        if (!gameState.playableIndices.contains(cardIndex)) {\r\n            Card card = currentPlayer.getHand().get(cardIndex);\r\n            view.showMessage(\"Cannot play \" + card + \" on \" + gameState.topDiscard);\r\n            return;\r\n        }\r\n\r\n        //get current card player will play\r\n        Card playedCard = currentPlayer.getHand().get(cardIndex);\r\n\r\n        // check if its wild because if it is we need to prompt for color\r\n        if (playedCard.getColor() == Card.Color.WILD) {\r\n            Card.Color chosenColor = null;\r\n            if (playedCard.getCurrentSide() == Card.Side.DARK) {\r\n                chosenColor = view.promptDarkWildColor();\r\n            } else {\r\n                chosenColor = view.promptWildColor();\r\n            }\r\n            if (chosenColor == null) {\r\n                view.showMessage(\"A color is required\");\r\n            } else {\r\n                model.playCard(currentPlayer,cardIndex, chosenColor);\r\n            }\r\n        }\r\n        else {\r\n            model.playCard(currentPlayer,cardIndex, null);\r\n        }\r\n    }\r\n\r\n    //handles drawing card from deck\r\n    private void onDrawCard()\r\n    {\r\n        model.drawCard();\r\n    }\r\n\r\n    //Handles ending current player turn and advances to next player.\r\n    private void onEndTurn()\r\n    {\r\n        model.endTurn();\r\n    }\r\n\r\n    /**\r\n     * Called when the game initialized\r\n     * refreshes the view with initial state.\r\n     */\r\n    @Override\r\n    public void onGameInitialized(GameState state) {\r\n        view.render(state);\r\n        view.showMessage(\"Game started! \" + state.currentPlayer.getName() + \" goes first.\");\r\n        //if first player is an ai\r\n        if (state.currentPlayer.isAI()) {\r\n            SwingUtilities.invokeLater(() -> {\r\n                model.checkAndProcessAITurn();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the game is initialized.\r\n     * Refreshes the view with the initial state and shows a welcome message.\r\n     *\r\n     * @param state The initial game state\r\n     */\r\n    @Override\r\n    public void onModelInit(GameState state) {\r\n        view.render(state);\r\n        view.showMessage(\"Game started! \" + state.currentPlayer.getName() + \" goes first.\");\r\n\r\n        if (state.currentPlayer.isAI()) {\r\n            SwingUtilities.invokeLater(() -> {\r\n                model.checkAndProcessAITurn();\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Called whenever the game state changes\r\n     * Refreshes the view to show current state\r\n     */\r\n    @Override\r\n    public void onStateUpdated(GameState state) {\r\n        view.render(state);\r\n    }\r\n\r\n    /**\r\n     * Called when the turn advances to next player\r\n     */\r\n    @Override\r\n    public void onTurnAdvanced(Player current, GameState state) {\r\n        view.render(state);\r\n\r\n        if (current.isAI()) {\r\n            SwingUtilities.invokeLater(() -> {\r\n                model.checkAndProcessAITurn();\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Called when a player wins round\r\n     */\r\n    @Override\r\n    public void onRoundWon(Player winner, int pointsAwarded, GameState state) {\r\n        view.render(state);\r\n        view.showMessage(winner + \" wins the round and scores \" + pointsAwarded + \" points!\");\r\n    }\r\n\r\n    /**\r\n     * called when a player wins game\r\n     */\r\n    @Override\r\n    public void onGameWon(Player winner, GameState state) {\r\n        view.render(state);\r\n        view.showMessage(\" \uD83C\uDF8A \" + winner + \"  WINS THE GAME WITH \" + winner.getScore() + \" POINTS! \uD83C\uDF8A \");\r\n    }\r\n\r\n    /**\r\n     * Called when an error occurs in the game model.\r\n     * Displays the error message to the user.\r\n     *\r\n     * @param message The error message\r\n     */\r\n    @Override\r\n    public void onError(String message) {\r\n        view.showMessage(\"Error: \" + message);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/controller/GameController.java b/uno project/src/controller/GameController.java
--- a/uno project/src/controller/GameController.java	(revision 49963df5e0818cc34f981de6f065167c53e7528f)
+++ b/uno project/src/controller/GameController.java	(date 1764808046076)
@@ -67,6 +67,10 @@
             else if (command.equals("NEXT"))
             {
                 onEndTurn();
+            } else if (command.equals("UNDO")) {
+
+            } else if (command.equals("REDO")) {
+
             }
             //this is only used during development in case a new command is added but not implemented here
             else
