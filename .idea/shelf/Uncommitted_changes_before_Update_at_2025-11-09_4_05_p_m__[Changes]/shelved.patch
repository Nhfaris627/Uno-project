Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ArtifactsWorkspaceSettings\">\r\n    <artifacts-to-build>\r\n      <artifact name=\"Uno-project:jar\" />\r\n    </artifacts-to-build>\r\n  </component>\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"bcb0cbf2-aeb5-48f9-b3e6-53e1adb500f5\" name=\"Changes\" comment=\"\">\r\n      <change afterPath=\"$PROJECT_DIR$/.idea/artifacts/Uno_project_jar.xml\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/uno project/src/META-INF/MANIFEST.MF\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;Nhfaris627&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/Nhfaris627/Uno-project&quot;,\r\n    &quot;accountId&quot;: &quot;62f45a82-8f2f-459c-8636-2a2ea5d4687a&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"34UcM5st6mii8GbE1O5YPYgUoMP\" />\r\n  <component name=\"ProjectLevelVcsManager\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;ASKED_SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\r\n    &quot;Application.Main.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.TestMain.executor&quot;: &quot;Run&quot;,\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;JUnit.CardTest.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.CardTest.testCardConstructorAndGettersColored.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.CardTest.testGetPointValueActionCards.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.DeckTest.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.DeckTest.testDeckConstructor.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.DeckTest.testSize.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.UnoGameTest.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.UnoGameTest.testPassTurn.executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager.252&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\r\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;onboarding.tips.debug.path&quot;: &quot;C:/Users/Leto/Desktop/quickstart/Uno-project/Src/src/Main.java&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Project&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ReadonlyStatusHandler\">\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n  </component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\Leto\\Desktop\\quickstart\\Uno-project\\uno project\\src\\main\\java\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Application.Main\">\r\n    <configuration name=\"Main\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Main\" />\r\n      <module name=\"Uno-project\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"DeckTest\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Uno-project\" />\r\n      <option name=\"PACKAGE_NAME\" value=\"\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"DeckTest\" />\r\n      <option name=\"TEST_OBJECT\" value=\"class\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"DeckTest.testSize\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Uno-project\" />\r\n      <option name=\"PACKAGE_NAME\" value=\"\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"DeckTest\" />\r\n      <option name=\"METHOD_NAME\" value=\"testSize\" />\r\n      <option name=\"TEST_OBJECT\" value=\"method\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"UnoGameTest\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Uno-project\" />\r\n      <option name=\"PACKAGE_NAME\" value=\"\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"UnoGameTest\" />\r\n      <option name=\"TEST_OBJECT\" value=\"class\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"UnoGameTest.testPassTurn\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Uno-project\" />\r\n      <option name=\"PACKAGE_NAME\" value=\"\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"UnoGameTest\" />\r\n      <option name=\"METHOD_NAME\" value=\"testPassTurn\" />\r\n      <option name=\"TEST_OBJECT\" value=\"method\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.Main\" />\r\n        <item itemvalue=\"JUnit.UnoGameTest\" />\r\n        <item itemvalue=\"JUnit.UnoGameTest.testPassTurn\" />\r\n        <item itemvalue=\"JUnit.DeckTest.testSize\" />\r\n        <item itemvalue=\"JUnit.DeckTest\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"bcb0cbf2-aeb5-48f9-b3e6-53e1adb500f5\" name=\"Changes\" comment=\"\" />\r\n      <created>1761271539476</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1761271539476</updated>\r\n      <workItem from=\"1761331395197\" duration=\"8013000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/uno project/src/main/java/Main.java</url>\r\n          <line>11</line>\r\n          <option name=\"timeStamp\" value=\"1\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 50f1716e4a7d582b5dcca84e7580a4a9719ee127)
+++ b/.idea/workspace.xml	(date 1762722217685)
@@ -1,18 +1,20 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ArtifactsWorkspaceSettings">
-    <artifacts-to-build>
-      <artifact name="Uno-project:jar" />
-    </artifacts-to-build>
-  </component>
   <component name="AutoImportSettings">
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="bcb0cbf2-aeb5-48f9-b3e6-53e1adb500f5" name="Changes" comment="">
-      <change afterPath="$PROJECT_DIR$/.idea/artifacts/Uno_project_jar.xml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/uno project/src/META-INF/MANIFEST.MF" afterDir="false" />
+    <list default="true" id="28d71652-fa6f-420b-9ba0-9b34549560df" name="Changes" comment="refactored GameController to implement added method in GameModelListeners interface.">
+      <change afterPath="$PROJECT_DIR$/data_structures_doc.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/uno project/src/GameController.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/uno project/src/GameModel.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/uno project/src/GameModelListener.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/uno project/src/GameState.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/uno project/src/GameView.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/uno project/src/MainGui.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.gitignore" beforeDir="false" afterPath="$PROJECT_DIR$/.gitignore" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/README.md" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -32,19 +34,19 @@
   <component name="GitHubPullRequestSearchHistory">{
   &quot;lastFilter&quot;: {
     &quot;state&quot;: &quot;OPEN&quot;,
-    &quot;assignee&quot;: &quot;Nhfaris627&quot;
+    &quot;assignee&quot;: &quot;NickyF30&quot;
   }
 }</component>
   <component name="GithubPullRequestsUISettings">{
   &quot;selectedUrlAndAccountId&quot;: {
-    &quot;url&quot;: &quot;https://github.com/Nhfaris627/Uno-project&quot;,
-    &quot;accountId&quot;: &quot;62f45a82-8f2f-459c-8636-2a2ea5d4687a&quot;
+    &quot;url&quot;: &quot;https://github.com/Nhfaris627/Uno-project.git&quot;,
+    &quot;accountId&quot;: &quot;322224e5-689e-42d0-b924-21fc1723226d&quot;
   }
 }</component>
   <component name="ProjectColorInfo">{
-  &quot;associatedIndex&quot;: 8
+  &quot;associatedIndex&quot;: 6
 }</component>
-  <component name="ProjectId" id="34UcM5st6mii8GbE1O5YPYgUoMP" />
+  <component name="ProjectId" id="35Debx5SA0ExQSD8rNt3LqY4FVq" />
   <component name="ProjectLevelVcsManager">
     <ConfirmationsSetting value="2" id="Add" />
   </component>
@@ -52,130 +54,77 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;ASKED_SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
-    &quot;Application.Main.executor&quot;: &quot;Run&quot;,
-    &quot;Application.TestMain.executor&quot;: &quot;Run&quot;,
-    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,
-    &quot;JUnit.CardTest.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.CardTest.testCardConstructorAndGettersColored.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.CardTest.testGetPointValueActionCards.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.DeckTest.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.DeckTest.testDeckConstructor.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.DeckTest.testSize.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.UnoGameTest.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.UnoGameTest.testPassTurn.executor&quot;: &quot;Run&quot;,
-    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,
-    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,
-    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager.252&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
-    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
-    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,
-    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
-    &quot;onboarding.tips.debug.path&quot;: &quot;C:/Users/Leto/Desktop/quickstart/Uno-project/Src/src/Main.java&quot;,
-    &quot;project.structure.last.edited&quot;: &quot;Project&quot;,
-    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,
-    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,
-    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
-  }
-}</component>
-  <component name="ReadonlyStatusHandler">
-    <option name="SHOW_DIALOG" value="false" />
-  </component>
-  <component name="RecentsManager">
-    <key name="MoveFile.RECENT_KEYS">
-      <recent name="C:\Users\Leto\Desktop\quickstart\Uno-project\uno project\src\main\java" />
-    </key>
-  </component>
-  <component name="RunManager" selected="Application.Main">
-    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
-      <option name="MAIN_CLASS_NAME" value="Main" />
-      <module name="Uno-project" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="DeckTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
-      <module name="Uno-project" />
-      <option name="PACKAGE_NAME" value="" />
-      <option name="MAIN_CLASS_NAME" value="DeckTest" />
-      <option name="TEST_OBJECT" value="class" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="DeckTest.testSize" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
-      <module name="Uno-project" />
-      <option name="PACKAGE_NAME" value="" />
-      <option name="MAIN_CLASS_NAME" value="DeckTest" />
-      <option name="METHOD_NAME" value="testSize" />
-      <option name="TEST_OBJECT" value="method" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="UnoGameTest" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
-      <module name="Uno-project" />
-      <option name="PACKAGE_NAME" value="" />
-      <option name="MAIN_CLASS_NAME" value="UnoGameTest" />
-      <option name="TEST_OBJECT" value="class" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <configuration name="UnoGameTest.testPassTurn" type="JUnit" factoryName="JUnit" temporary="true" nameIsGenerated="true">
-      <module name="Uno-project" />
-      <option name="PACKAGE_NAME" value="" />
-      <option name="MAIN_CLASS_NAME" value="UnoGameTest" />
-      <option name="METHOD_NAME" value="testPassTurn" />
-      <option name="TEST_OBJECT" value="method" />
-      <method v="2">
-        <option name="Make" enabled="true" />
-      </method>
-    </configuration>
-    <recent_temporary>
-      <list>
-        <item itemvalue="Application.Main" />
-        <item itemvalue="JUnit.UnoGameTest" />
-        <item itemvalue="JUnit.UnoGameTest.testPassTurn" />
-        <item itemvalue="JUnit.DeckTest.testSize" />
-        <item itemvalue="JUnit.DeckTest" />
-      </list>
-    </recent_temporary>
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Application.MainGui.executor": "Run",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager.252": "true",
+    "RunOnceActivity.git.unshallow": "true",
+    "git-widget-placeholder": "Merging main",
+    "ignore.virus.scanning.warn.message": "true",
+    "junie.onboarding.icon.badge.shown": "true",
+    "kotlin-language-version-configured": "true",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)",
+    "nodejs_package_manager_path": "npm",
+    "to.speed.mode.migration.done": "true",
+    "vue.rearranger.settings.migration": "true"
+  }
+}]]></component>
+  <component name="SharedIndexes">
+    <attachedChunks>
+      <set>
+        <option value="bundled-jdk-9823dce3aa75-bf35d07a577b-intellij.indexing.shared.core-IU-252.25557.131" />
+      </set>
+    </attachedChunks>
   </component>
   <component name="TaskManager">
     <task active="true" id="Default" summary="Default task">
-      <changelist id="bcb0cbf2-aeb5-48f9-b3e6-53e1adb500f5" name="Changes" comment="" />
-      <created>1761271539476</created>
+      <changelist id="28d71652-fa6f-420b-9ba0-9b34549560df" name="Changes" comment="" />
+      <created>1762649145328</created>
       <option name="number" value="Default" />
       <option name="presentableId" value="Default" />
-      <updated>1761271539476</updated>
-      <workItem from="1761331395197" duration="8013000" />
+      <updated>1762649145328</updated>
+      <workItem from="1762649146288" duration="25000" />
+      <workItem from="1762651390942" duration="3022000" />
+      <workItem from="1762654594884" duration="1049000" />
+      <workItem from="1762667972612" duration="304000" />
     </task>
+    <task id="LOCAL-00001" summary="fixed all errors that were associated with wrong naming, and added/corrected method names and parameters in Model Listeners to fix erros in GameModel">
+      <option name="closed" value="true" />
+      <created>1762718214927</created>
+      <option name="number" value="00001" />
+      <option name="presentableId" value="LOCAL-00001" />
+      <option name="project" value="LOCAL" />
+      <updated>1762718214927</updated>
+    </task>
+    <task id="LOCAL-00002" summary="refactored GameController to implement added method in GameModelListeners interface.">
+      <option name="closed" value="true" />
+      <created>1762718648916</created>
+      <option name="number" value="00002" />
+      <option name="presentableId" value="LOCAL-00002" />
+      <option name="project" value="LOCAL" />
+      <updated>1762718648916</updated>
+    </task>
+    <task id="LOCAL-00003" summary="refactored GameController to implement added method in GameModelListeners interface.">
+      <option name="closed" value="true" />
+      <created>1762718819816</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1762718819816</updated>
+    </task>
+    <option name="localTasksCounter" value="4" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
     <option name="version" value="3" />
   </component>
-  <component name="XDebuggerManager">
-    <breakpoint-manager>
-      <breakpoints>
-        <line-breakpoint enabled="true" type="java-line">
-          <url>file://$PROJECT_DIR$/uno project/src/main/java/Main.java</url>
-          <line>11</line>
-          <option name="timeStamp" value="1" />
-        </line-breakpoint>
-      </breakpoints>
-    </breakpoint-manager>
+  <component name="VcsManagerConfiguration">
+    <MESSAGE value="fixed all errors that were associated with wrong naming, and added/corrected method names and parameters in Model Listeners to fix erros in GameModel" />
+    <MESSAGE value="refactored GameController to implement added method in GameModelListeners interface." />
+    <option name="LAST_COMMIT_MESSAGE" value="refactored GameController to implement added method in GameModelListeners interface." />
   </component>
 </project>
\ No newline at end of file
Index: data_structures_doc.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/data_structures_doc.md b/data_structures_doc.md
new file mode 100644
--- /dev/null	(date 1762721778183)
+++ b/data_structures_doc.md	(date 1762721778183)
@@ -0,0 +1,230 @@
+# Data Structure Explanation - UNO Game Project
+
+## Overview
+This document provides a detailed explanation of the data structures used in the UNO game implementation, their rationale, and the operations performed on them.
+
+---
+
+## 1. ArrayList<Card> - Deck and Player Hands
+
+### Usage Locations:
+- **Deck.java**: `private List<Card> cards`
+- **Player.java**: `private List<Card> hand`
+- **UnoGame.java**: `private List<Card> discardPile`
+
+### Rationale:
+ArrayList was chosen for card collections because:
+- **Dynamic Sizing**: Cards are frequently added and removed during gameplay
+- **Indexed Access**: O(1) time complexity for accessing cards by position, essential for displaying numbered card choices to players
+- **Sequential Access**: Iteration through all cards is frequently needed for displaying hands and calculating scores
+- **Efficient Removal**: While removal from middle is O(n), this occurs infrequently enough to not impact performance
+
+### Key Operations:
+| Operation | Method | Time Complexity | Usage |
+|-----------|--------|-----------------|-------|
+| Add card | `add(Card)` | O(1) amortized | Drawing cards, adding to discard pile |
+| Remove card | `remove(int index)` | O(n) | Playing cards from hand |
+| Remove specific | `remove(Object)` | O(n) | Playing drawn card immediately |
+| Access by index | `get(int index)` | O(1) | Selecting cards, displaying hands |
+| Size check | `size()` | O(1) | Checking hand size, deck size |
+| Check empty | `isEmpty()` | O(1) | Validating deck/hand status |
+| Iteration | `for-each loop` | O(n) | Displaying cards, calculating values |
+
+### Example Usage:
+```java
+// Deck - Drawing a card
+public Card drawCard() {
+    if (cards.isEmpty()) return null;
+    return cards.remove(cards.size() - 1);  // O(1) removal from end
+}
+
+// Player - Calculating hand value
+public int calculateHandValue() {
+    int total = 0;
+    for (Card card : hand) {  // O(n) iteration
+        total += card.getPointValue();
+    }
+    return total;
+}
+```
+
+---
+
+## 2. ArrayList<Player> - Game Players
+
+### Usage Location:
+- **UnoGame.java**: `private List<Player> players`
+
+### Rationale:
+ArrayList was chosen for managing players because:
+- **Fixed Size After Creation**: Number of players (2-4) is set at game start and never changes
+- **Indexed Access**: O(1) access needed for current player index and winner determination
+- **Order Preservation**: Maintains turn order throughout the game
+- **Simple Iteration**: Easy to cycle through players for scoring and state display
+
+### Key Operations:
+| Operation | Method | Time Complexity | Usage |
+|-----------|--------|-----------------|-------|
+| Access player | `get(int index)` | O(1) | Getting current player, accessing by winner index |
+| Get all players | `getPlayers()` | O(1) | Displaying all players, calculating scores |
+| Iteration | `for-each loop` | O(n) | Dealing cards, calculating round scores |
+| Size check | `size()` | O(1) | Modulo operations for turn cycling |
+
+### Example Usage:
+```java
+// Cycling through players
+public Player getCurrentPlayer() {
+    return players.get(currentPlayerIndex);  // O(1) access
+}
+
+// Round score calculation
+for (int i = 0; i < players.size(); i++) {  // O(n) iteration
+    if (i != winnerIndex) {
+        totalPoints += players.get(i).calculateHandValue();
+    }
+}
+```
+
+---
+
+## 3. ArrayList<Integer> - Playable Card Indices
+
+### Usage Location:
+- **UnoGame.java**: `getPlayableCards()` method returns `List<Integer>`
+
+### Rationale:
+ArrayList of integers was chosen for playable card indices because:
+- **Dynamic Building**: Number of playable cards varies each turn
+- **Reference Mapping**: Stores indices rather than cards themselves, maintaining connection to player's hand
+- **Membership Testing**: `contains()` method validates player's card choice
+- **Display Formatting**: Easy iteration for showing playable options to user
+
+### Key Operations:
+| Operation | Method | Time Complexity | Usage |
+|-----------|--------|-----------------|-------|
+| Add index | `add(Integer)` | O(1) amortized | Building list of playable cards |
+| Check contains | `contains(Object)` | O(n) | Validating player's card choice |
+| Iteration | `for-each loop` | O(n) | Displaying playable cards to user |
+| Check empty | `isEmpty()` | O(1) | Determining if player must draw |
+
+### Example Usage:
+```java
+// Building playable cards list
+private List<Integer> getPlayableCards(Player player) {
+    List<Integer> playableCards = new ArrayList<>();
+    for (int i = 0; i < player.getHandSize(); i++) {
+        if (isCardPlayable(player.getHand().get(i))) {
+            playableCards.add(i);  // O(1) add
+        }
+    }
+    return playableCards;
+}
+
+// Validating choice
+if (playableCards.contains(choice)) {  // O(n) search
+    return choice;
+}
+```
+
+---
+
+## 4. Primitive Data Types
+
+### Integer Variables:
+- **currentPlayerIndex** (UnoGame): Tracks whose turn it is
+- **score** (Player): Accumulates points across rounds
+- **Time Complexity**: O(1) for all operations (increment, comparison, modulo)
+
+### Boolean Variables:
+- **isClockwise** (UnoGame): Tracks direction of play for REVERSE cards
+- **Time Complexity**: O(1) for all operations (toggle, check)
+
+### Rationale:
+Primitives were chosen over wrapper classes (Integer, Boolean) because:
+- **Performance**: No object creation overhead
+- **Memory Efficiency**: Stored directly on stack
+- **Simplicity**: Direct value semantics, no null checks needed
+
+---
+
+## 5. Enumerations
+
+### Card.Color and Card.Value:
+```java
+public enum Color { RED, BLUE, GREEN, YELLOW, WILD }
+public enum Value { ZERO, ONE, ..., NINE, SKIP, REVERSE, DRAW_ONE, WILD, WILD_DRAW_TWO }
+```
+
+### Rationale:
+Enums were chosen over String constants because:
+- **Type Safety**: Compile-time checking prevents invalid values
+- **Performance**: Comparison is O(1) using reference equality
+- **Maintainability**: Adding new colors/values requires updating enum only
+- **Memory Efficiency**: Single instance per value (flyweight pattern)
+
+### Key Operations:
+| Operation | Time Complexity | Usage |
+|-----------|-----------------|-------|
+| Comparison | O(1) | Checking card color/value matches |
+| Switch statement | O(1) | Calculating point values, handling special cards |
+| valueOf() | O(n) where n=enum size | Parsing user color input for Wild cards |
+
+---
+
+## 6. Design Trade-offs and Alternatives Considered
+
+### Why Not LinkedList?
+- **Pro**: O(1) removal from arbitrary positions
+- **Con**: O(n) indexed access, which is frequently needed for card selection
+- **Decision**: ArrayList's O(1) indexed access outweighs occasional O(n) removal cost
+
+### Why Not HashMap for Players?
+- **Pro**: O(1) access by name
+- **Con**: Doesn't preserve turn order, requires additional index tracking
+- **Decision**: ArrayList maintains natural turn order and index-based access
+
+### Why Not Stack for Deck/Discard?
+- **Pro**: Models real-world card stacks
+- **Con**: Limited to top-only access, no iteration support
+- **Decision**: ArrayList provides flexibility for shuffle, iteration, and access while still supporting stack-like operations
+
+### Why Not Array for Cards?
+- **Pro**: Slightly better performance, lower memory overhead
+- **Con**: Fixed size, requires manual resizing logic
+- **Decision**: ArrayList's dynamic sizing simplifies code with negligible performance impact
+
+---
+
+## 7. Performance Analysis
+
+### Overall Time Complexity by Operation:
+| Game Operation | Dominant Data Structure Operation | Time Complexity |
+|----------------|-----------------------------------|-----------------|
+| Playing a card | Remove from ArrayList by index | O(n) |
+| Drawing a card | Remove from ArrayList end | O(1) |
+| Displaying hand | Iterate through ArrayList | O(n) |
+| Checking playable cards | Iterate through hand, check each card | O(n √ó m)* |
+| Calculating score | Iterate through all players and their cards | O(p √ó c)** |
+| Getting current player | Access ArrayList by index | O(1) |
+| Checking card validity | Enum comparisons | O(1) |
+
+*where n = hand size, m = validation operations per card
+**where p = number of players, c = average cards per player
+
+### Space Complexity:
+- **Deck**: O(108) = O(1) - fixed deck size
+- **Player Hands**: O(p √ó c) where p = players (2-4), c = cards per player (varies)
+- **Discard Pile**: O(n) where n = cards played (grows throughout game)
+- **Total**: O(n) where n is total number of cards in play
+
+---
+
+## 8. Conclusion
+
+The choice of ArrayList as the primary data structure throughout the UNO game provides an optimal balance of:
+- **Simplicity**: Easy to understand and maintain
+- **Performance**: O(1) indexed access for frequent operations
+- **Flexibility**: Dynamic sizing handles variable game states
+- **Java Integration**: Works seamlessly with enhanced for-loops and Collections utilities
+
+While other data structures could optimize specific operations, ArrayList's versatility makes it the ideal choice for this implementation, where indexed access and iteration are the dominant operations.
\ No newline at end of file
Index: uno project/src/MainGui.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/MainGui.java b/uno project/src/MainGui.java
new file mode 100644
--- /dev/null	(date 1762721778185)
+++ b/uno project/src/MainGui.java	(date 1762721778185)
@@ -0,0 +1,21 @@
+import javax.swing.*;
+import java.awt.*;
+
+public class MainGui {
+    public static void main(String[] args) {
+        SwingUtilities.invokeLater(() -> {
+            GameView view = new GameView();
+            JFrame frame = new JFrame("UNO");
+
+            int playercount = view.promptPlayerCount(frame);
+
+            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);// expose root JPanel
+            frame.setContentPane(view.getRoot());
+            frame.pack();
+            frame.setLocationRelativeTo(null);
+            frame.setVisible(true);
+        });
+    }
+
+
+}
Index: uno project/src/GameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/GameController.java b/uno project/src/GameController.java
new file mode 100644
--- /dev/null	(date 1762721778183)
+++ b/uno project/src/GameController.java	(date 1762721778183)
@@ -0,0 +1,194 @@
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+/**
+ * COntroller for uno game implementing MVC pattern
+ * Mediates between GameModel and GameView
+ * Handles user input via ActionListener and updates the view via GameModelListener
+ *
+ * @author Nicky Fang 101304731
+ *
+ * @author Bhagya Patel 101324150
+ * @version 2
+ * @brief added methods and restructured method parameters
+ *
+ */
+public class GameController implements ActionListener, GameModelListener {
+
+    //
+    private GameModel model;
+    private GameView view;
+
+    /**
+     *
+     * @param model The game model
+     * @param view The game view
+     */
+    public GameController(GameModel model, GameView view) {
+        this.model = model;
+        this.view = view;
+
+        //add this controller to the model
+
+        model.addListener(this);
+
+        //add this controller to the view
+        view.bindController(this);
+    }
+
+    /**
+     * Handles button clicks and other actions from the view
+     * Sends commands to appropriate handler method
+     * @param e the event to be processed
+     */
+    @Override
+    public void actionPerformed(ActionEvent e) {
+        String command = e.getActionCommand();
+
+        try {
+            if (command.startsWith("PLAY:"))
+            {
+                //extract card index from command
+                int cardIndex = Integer.parseInt(command.substring(5));
+                onPlayCard(cardIndex);
+            }
+            else if (command.equals("DRAW"))
+            {
+                onDrawCard();
+            }
+            else if (command.equals("NEXT"))
+            {
+                onEndTurn();
+            }
+            //this is only used during development in case a new command is added but not implemented here
+            else
+            {
+                view.showMessage("Unknown command: " + command);
+            }
+        }
+
+        catch (Exception ex) {
+            view.showMessage("Error: " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Handles playing card from current hand
+     * verifies card index before sending to model
+     * @param cardIndex
+     */
+    private void onPlayCard(int cardIndex) {
+
+        //get game state
+        GameState gameState = model.getState();
+        Player currentPlayer = gameState.currentPlayer;
+
+        //check card index
+        if (cardIndex < 0 || cardIndex >= currentPlayer.getHandSize()) {
+            view.showMessage("Invalid card index: " + cardIndex);
+            return;
+        }
+
+        //check if car d playable
+        if (!gameState.playableIndices.contains(cardIndex)) {
+            Card card = currentPlayer.getHand().get(cardIndex);
+            view.showMessage("Cannot play " + card + " on " + gameState.topDiscard);
+            return;
+        }
+
+        //get current card player will play
+        Card playedCard = currentPlayer.getHand().get(cardIndex);
+
+        // check if its wild because if it is we need to prompt for color
+        if (playedCard.getColor() == Card.Color.WILD) {
+            Card.Color chosenColor = view.promptWildColor();
+            model.playCard(currentPlayer,cardIndex, chosenColor);
+        }
+        else {
+            model.playCard(currentPlayer,cardIndex, null);
+
+        }
+    }
+
+    //handles drawing card from deck
+    private void onDrawCard()
+    {
+        model.drawCard();
+    }
+
+    //Handles ending current player turn and advances to next player.
+    private void onEndTurn()
+    {
+        model.endTurn();
+    }
+
+    /**
+     * Called when the game initialized
+     * refreshes the view with initial state.
+     */
+    @Override
+    public void onGameInitialized(GameState state) {
+        view.render(state);
+        view.showMessage("Game started! " + state.currentPlayer.getName() + " goes first.");
+    }
+
+    /**
+     * Called when the game is initialized.
+     * Refreshes the view with the initial state and shows a welcome message.
+     *
+     * @param state The initial game state
+     */
+    @Override
+    public void onModelInit(GameState state) {
+        view.render(state);
+        view.showMessage("Game started! " + state.currentPlayer.getName() + " goes first.");
+    }
+
+
+    /**
+     * Called whenever the game state changes
+     * Refreshes the view to show current state
+     */
+    @Override
+    public void onStateUpdated(GameState state) {
+        view.render(state);
+    }
+
+    /**
+     * Called when the turn advances to next player
+     */
+    @Override
+    public void onTurnAdvanced(Player current, GameState state) {
+        view.render(state);
+    }
+
+    /**
+     * Called when a player wins round
+     */
+    @Override
+    public void onRoundWon(Player winner, int pointsAwarded, GameState state) {
+        view.render(state);
+        view.showMessage(winner + " wins the round and scores " + pointsAwarded + " points!");
+    }
+
+    /**
+     * called when a player wins game
+     */
+    @Override
+    public void onGameWon(Player winner, GameState state) {
+        view.render(state);
+        view.showMessage(" üéä " + winner + "  WINS THE GAME WITH " + winner.getScore() + " POINTS! üéä ");
+    }
+
+    /**
+     * Called when an error occurs in the game model.
+     * Displays the error message to the user.
+     *
+     * @param message The error message
+     */
+    @Override
+    public void onError(String message) {
+        view.showMessage("Error: " + message);
+    }
+
+}
Index: uno project/src/GameView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/GameView.java b/uno project/src/GameView.java
new file mode 100644
--- /dev/null	(date 1762721778185)
+++ b/uno project/src/GameView.java	(date 1762721778185)
@@ -0,0 +1,210 @@
+/**
+ * The view for the uno GUI
+ *
+ * @author Ivan Arkhipov 101310636
+ * @version 1.0
+ */
+
+import javax.swing.*;
+import java.awt.*;
+import java.util.List;
+
+public final class GameView {
+    private GameController controller;
+
+    //root panel
+    private final JPanel root = new JPanel();
+
+    //top card
+    private final JLabel topCardText = new JLabel("-", SwingConstants.CENTER);
+
+    //status info
+    private final JLabel currentLabel = new JLabel("Current: -");
+    private final JLabel statusLabel = new JLabel("Status: -");
+
+    //hand section
+    private final JPanel handStrip = new JPanel(); // BoxLayout.X_AXIS
+    private final JScrollPane handScroll = new JScrollPane(handStrip);
+    private final JButton nextBtn = new JButton("Next");
+    private final JButton drawBtn = new JButton("Draw Card");
+
+    //scoreboard
+    private final JTextArea scoreArea = new JTextArea(3, 30);
+
+    /**
+     * Constructor for the GameView class. Sets up panels and layout for the GUI
+     */
+    public GameView() {
+        root.setLayout(new BoxLayout(root, BoxLayout.Y_AXIS));
+        root.setBorder(BorderFactory.createEmptyBorder(8,8,8,8));
+
+        //top card section
+        JPanel top = titled("Top Card");
+        top.setLayout(new BorderLayout());
+        top.add(topCardText, BorderLayout.CENTER);
+        root.add(top);
+
+        //status section
+        JPanel status = titled("Status");
+        status.setLayout(new GridLayout(2,1));
+        status.add(currentLabel);
+        status.add(statusLabel);
+        root.add(status);
+
+        //hand section
+        JPanel hand = titled("Your Hand");
+        hand.setLayout(new BorderLayout());
+        handStrip.setLayout(new BoxLayout(handStrip, BoxLayout.X_AXIS));
+        handScroll.setBorder(null);
+        hand.add(handScroll, BorderLayout.CENTER);
+        root.add(hand);
+
+        //scoreboard section
+        JPanel score = titled("Scoreboard");
+        score.setLayout(new BorderLayout());
+        scoreArea.setEditable(false);
+        score.add(new JScrollPane(scoreArea), BorderLayout.CENTER);
+        root.add(score);
+
+        //set action commands for controller
+        nextBtn.setActionCommand("NEXT");
+        drawBtn.setActionCommand("DRAW");
+    }
+
+    /**
+     * Helper method to create a titled section as per the example
+     * @param title the title of the section
+     * @return a JPanel object with a set title
+     */
+    private JPanel titled(String title) {
+        JPanel p = new JPanel();
+        p.setBorder(BorderFactory.createTitledBorder(title));
+        return p;
+    }
+
+    /**
+     * Get the root pane from the view
+     * @return the root pane
+     */
+    public JPanel getRoot() { return root; }
+
+    /**
+     * Add the controller as an action listener
+     * @param c the controller
+     */
+    public void bindController(GameController c) {
+        controller = c;
+        nextBtn.addActionListener(c);
+        drawBtn.addActionListener(c);
+    }
+
+    /**
+     * Render the entire screen based on the GameState object, emitted by the model
+     * @param s the GameState to render
+     */
+    public void render(GameState s) {
+        //top card
+        topCardText.setText(s.topDiscard == null ? "-" : s.topDiscard.toString());
+
+        //status section
+        currentLabel.setText("Current Player: " + s.currentPlayer.getName() +
+                " | Deck: " + s.deckSize + (s.clockwise ? "  ‚Üí" : "  ‚Üê"));
+        statusLabel.setText("Status: ");
+
+        //build hand section panel
+        handStrip.removeAll();
+        handStrip.add(wrapLeft(nextBtn));
+
+        //fill the hand strip with cards from the players' hand
+        List<Card> hand = s.currentPlayer.getHand();
+        for (int i = 0; i < hand.size(); i++) {
+            Card c = hand.get(i);
+            JButton cardBtn = new JButton(c.toString());
+            final int idx = i;
+            boolean playable = s.playableIndices.contains(i);
+            if (playable) cardBtn.setBorder(BorderFactory.createLineBorder(java.awt.Color.GREEN, 2));
+
+            //controller handles playing card
+            cardBtn.setActionCommand("PLAY:" + idx);
+            cardBtn.addActionListener(controller);
+            handStrip.add(Box.createHorizontalStrut(16));
+            handStrip.add(cardBtn);
+        }
+
+        handStrip.add(Box.createHorizontalGlue());
+        handStrip.add(wrapRight(drawBtn));
+
+        handStrip.revalidate();
+        handStrip.repaint();
+
+        //set button playability
+        boolean hasPlayable = !s.playableIndices.isEmpty();
+        nextBtn.setEnabled(true);
+        drawBtn.setEnabled(!hasPlayable);
+
+        //scoreboard info
+        StringBuilder sb = new StringBuilder("Scoreboard:\n");
+        for (Player p : s.players) sb.append(p.getName()).append(": ").append(p.getScore()).append("\n");
+        scoreArea.setText(sb.toString());
+    }
+
+    /**
+     * Helper method to wrap a component to the left using borderLayout
+     * @param c the component to wrap
+     * @return the wrapped component
+     */
+    private JComponent wrapLeft(JComponent c) {
+        JPanel p = new JPanel(new BorderLayout());
+        p.add(c, BorderLayout.WEST);
+        return p;
+    }
+
+    /**
+     * Helper method to wrap a component to the right using borderLayout
+     * @param c the component to wrap
+     * @return the wrapped component
+     */
+    private JComponent wrapRight(JComponent c) {
+        JPanel p = new JPanel(new BorderLayout());
+        p.add(c, BorderLayout.EAST);
+        return p;
+    }
+
+    /**
+     * Create a pop up dialogue to prompt the user for the color they want to play after playing wild card
+     * @return return the color chosen by the user
+     */
+    public Card.Color promptWildColor() {
+        Object[] options = { "RED", "YELLOW", "GREEN", "BLUE" };
+        int choice = JOptionPane.showOptionDialog(root, "Choose a color", "Wild",
+                JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
+        if (choice < 0) return Card.Color.RED;
+        return Card.Color.valueOf(options[choice].toString());
+    }
+
+    /**
+     * Show message to the user
+     * @param msg the message to show
+     */
+    public void showMessage(String msg) {
+        JOptionPane.showMessageDialog(root, msg, "UNO", JOptionPane.INFORMATION_MESSAGE);
+    }
+
+    /**
+     * Create a pop up dialogue to prompt the user for the number of players
+     * @return the number of players
+     */
+    public int promptPlayerCount(Component parent) {
+        Object[] options = {2, 3, 4};
+        Object choice = JOptionPane.showInputDialog(
+                parent,
+                "Select number of players (2‚Äì4):",
+                "UNO Setup",
+                JOptionPane.QUESTION_MESSAGE,
+                null,
+                options,
+                options[0]);
+        if (choice == null) return -1;
+        return (Integer) choice;
+    }
+}
\ No newline at end of file
Index: uno project/src/GameModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/GameModel.java b/uno project/src/GameModel.java
new file mode 100644
--- /dev/null	(date 1762721778185)
+++ b/uno project/src/GameModel.java	(date 1762721778185)
@@ -0,0 +1,459 @@
+import java.util.*;
+/**
+ * Core model for the UNO game
+ * manages game state, rules, and notifies listeners of changes.
+ * this class has no UI or I/O dependencies, all interactions happen through
+ * the GameModelListener observer pattern
+ * 
+ * @author Bhagya Patel, 101324150
+ * @version 2.0
+ */
+
+public class GameModel
+{
+
+    private List<Player> players;
+    private List<Card> discardPile;
+    private Deck deck;
+    private int currentPlayerIndex;
+    private boolean isClockwise;
+    private List<GameModelListener> listeners;
+    private static final int TARGET_SCORE = 500;
+    private static final int INITIAL_HAND_SIZE = 7;
+
+    /**
+     * Creates a new GameModel with specified player names.
+     * initializes the deck, discard pile. and sets up the game state.
+     * 
+     * @param playerCount List of player names (must be 2-4 players)
+     * @throws IllegalArgumentException if player count is not between 2 and 4
+     */
+    public GameModel(int playerCount){
+        if(playerCount == 0 || playerCount < 2 || playerCount> 4){
+            throw new IllegalArgumentException("Game requires 2-4 players");
+        }
+
+        this.players = new ArrayList<>();
+        for(int i = 0; i < playerCount; i++){
+            Player player = new Player("Player " + (i+1));
+            this.players.add(player);
+        }
+
+        this.deck = new Deck();
+        this.discardPile = new ArrayList<>();
+        this.currentPlayerIndex = 0;
+        this.isClockwise = true;
+        this.listeners = new ArrayList<>();
+    }
+
+    /**
+     * Starts a new game by dealing cards and setting up the initial discard pile.
+     * Fires onGameInitialized event to all listeners
+     */
+    public void startGame(){
+        // Deal initial cards to each player
+        for (Player player: players){
+            for( int i = 0; i < INITIAL_HAND_SIZE; i++){
+                Card card = deck.drawCard();
+                if (card != null){
+                    player.drawCard(card);
+                }
+            }
+        }
+
+        // Place first card on discard pile (avoid starting with special cards)
+        Card firstCard = deck.drawCard();
+        while (firstCard != null && isSpecialCard(firstCard)){
+            deck.drawCard(); // Put it back somehow, for simplicity just draw another
+            firstCard = deck.drawCard();
+        }
+
+        if (firstCard != null){
+            discardPile.add(firstCard);
+        }
+
+        fireModelInit();
+    }
+
+    /**
+     * Plays a card from the current player's hand.
+     * Handles wild card color selection and special card effects.
+     *
+     * @param player The player playing the card (unused in this simplified version)
+     * @param handIndex Index of the card in the current player's hand
+     * @param chosenColor Color chosen for wild cards (null for non-wild cards)
+     */
+    public void playCard(Player player, int handIndex, Card.Color chosenColor) {
+        Player currentPlayer = players.get(currentPlayerIndex);
+
+        if (handIndex < 0 || handIndex >= currentPlayer.getHandSize()) {
+            fireError("Invalid card index: " + handIndex);
+            return;
+        }
+
+        Card playedCard = currentPlayer.getHand().get(handIndex);
+
+        // Validate the card can be played
+        if (!isCardPlayable(playedCard)) {
+            fireError("Cannot play " + playedCard + " on " + getTopDiscardCard());
+            return;
+        }
+
+        // Remove card from hand and add to discard pile
+        currentPlayer.getHand().remove(handIndex);
+        discardPile.add(playedCard);
+
+        // Handle wild card color choice
+        if (playedCard.getColor() == Card.Color.WILD && chosenColor != null) {
+            playedCard.setColor(chosenColor);
+        }
+
+        fireStateUpdated();
+
+        // Check for round winner
+        if (currentPlayer.getHandSize() == 0) {
+            handleRoundWin(currentPlayerIndex);
+            return;
+        }
+
+        // Handle special card effects
+        handleSpecialCard(playedCard);
+
+        fireStateUpdated();
+    }
+
+    /**
+     * Current player draws a card from the deck
+     * @return The drawn card, or null if deck is empty
+     */
+    public Card drawCard(){
+        Player currentPlayer = players.get(currentPlayerIndex);
+
+        Card drawnCard = deck.drawCard();
+
+        if (drawnCard != null){
+            currentPlayer.drawCard(drawnCard);
+            fireStateUpdated();
+            return drawnCard;
+        } else{
+            fireError("Deck is empty!");
+            return null;
+        }
+    }
+
+    /**
+     * Ends the current player's turn and advances to the next player.
+     */
+    public void endTurn() {
+        advanceToNextPlayer();
+        fireTurnAdvanced(players.get(currentPlayerIndex));
+    }
+
+    /**
+     * Calculates and awards points when a player wins a round.
+     * The winner gets points equal to the sum of all cards in opponents' hands.
+     * 
+     * @param winnerIndex The index of the winning player
+     * @return The total points awarded
+     */
+    public int calculateRoundScore(int winnerIndex) {
+        Player winner = players.get(winnerIndex);
+        int totalPoints = 0;
+        
+        // Calculate points from all opponents' hands
+        for (int i = 0; i < players.size(); i++) {
+            if (i != winnerIndex) {
+                Player opponent = players.get(i);
+                int handValue = opponent.calculateHandValue();
+                totalPoints += handValue;
+            }
+        }
+        
+        winner.addScore(totalPoints);
+        return totalPoints;
+    }
+
+    /**
+     * Checks if any player has reached the target score to win the game.
+     * 
+     * @param targetScore The score needed to win the game (typically 500)
+     * @return The winning player, or null if no winner yet
+     */
+    public Player checkForGameWinner(int targetScore) {
+        for (Player player : players) {
+            if (player.getScore() >= targetScore) {
+                return player;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Adds a listener to receive game events.
+     * 
+     * @param l The listener to add
+     */
+    public void addListener(GameModelListener l) {
+        if (l != null && !listeners.contains(l)) {
+            listeners.add(l);
+        }
+    }
+
+    /**
+     * Removes a listener from receiving game events.
+     * 
+     * @param l The listener to remove
+     */
+    public void removeListener(GameModelListener l) {
+
+        listeners.remove(l);
+    }
+    
+    //HELPER METHODS
+    /**
+     * Gets the top card of the discard pile.
+     * 
+     * @return The top card, or null if discard pile is empty
+     */
+    private Card getTopDiscardCard() {
+        if (discardPile.isEmpty()) {
+            return null;
+        }
+        return discardPile.get(discardPile.size() - 1);
+    }
+
+    /**
+     * Gets indices of playable cards in current player's hand.
+     * 
+     * @return List of indices representing playable cards
+     */
+    private List<Integer> getPlayableIndices() {
+        Player currentPlayer = players.get(currentPlayerIndex);
+        List<Integer> playableIndices = new ArrayList<>();
+        Card topCard = getTopDiscardCard();
+        
+        if (topCard == null) {
+            // All cards playable if no top card
+            for (int i = 0; i < currentPlayer.getHandSize(); i++) {
+                playableIndices.add(i);
+            }
+            return playableIndices;
+        }
+        
+        for (int i = 0; i < currentPlayer.getHandSize(); i++) {
+            Card card = currentPlayer.getHand().get(i);
+            if (isCardPlayable(card)) {
+                playableIndices.add(i);
+            }
+        }
+        
+        return playableIndices;
+    }
+    
+    /**
+     * Checks if a card can be played on the current discard pile.
+     * 
+     * @param card The card to check
+     * @return true if the card is playable, false otherwise
+     */
+    private boolean isCardPlayable(Card card) {
+        Card topCard = getTopDiscardCard();
+        
+        if (topCard == null) {
+            return true;
+        }
+        
+        // Wild cards can always be played
+        if (card.getColor() == Card.Color.WILD) {
+            return true;
+        }
+        
+        // Same color
+        if (card.getColor() == topCard.getColor()) {
+            return true;
+        }
+        
+        // Same value
+        if (card.getValue() == topCard.getValue()) {
+            return true;
+        }
+        
+        return false;
+    }
+    
+    /**
+     * Checks if a card is a special action card.
+     * 
+     * @param card The card to check
+     * @return true if the card is special, false otherwise
+     */
+    private boolean isSpecialCard(Card card) {
+        Card.Value value = card.getValue();
+        return value == Card.Value.SKIP || value == Card.Value.REVERSE ||
+               value == Card.Value.DRAW_ONE || value == Card.Value.WILD ||
+               value == Card.Value.WILD_DRAW_TWO;
+    }
+    
+    /**
+     * Handles the effects of special cards.
+     * 
+     * @param playedCard The special card that was played
+     */
+    private void handleSpecialCard(Card playedCard) {
+        switch (playedCard.getValue()) {
+            case SKIP:
+                advanceToNextPlayer(); // Skip next player
+                break;
+                
+            case REVERSE:
+                isClockwise = !isClockwise;
+                if (players.size() == 2) {
+                    // In 2-player game, reverse acts like skip
+                    advanceToNextPlayer();
+                }
+                break;
+                
+            case DRAW_ONE:
+                advanceToNextPlayer();
+                Player drawOneTarget = players.get(currentPlayerIndex);
+                Card drawn = deck.drawCard();
+                if (drawn != null) {
+                    drawOneTarget.drawCard(drawn);
+                }
+                break;
+                
+            case WILD_DRAW_TWO:
+                advanceToNextPlayer();
+                Player drawTwoTarget = players.get(currentPlayerIndex);
+                for (int i = 0; i < 2; i++) {
+                    Card drawnCard = deck.drawCard();
+                    if (drawnCard != null) {
+                        drawTwoTarget.drawCard(drawnCard);
+                    }
+                }
+                break;
+                
+            case WILD:
+                // Color already set in playCard method
+                break;
+                
+            default:
+                // Regular number card, no special effect
+                break;
+        }
+    }
+    
+    /**
+     * Advances the turn to the next player based on direction.
+     */
+    private void advanceToNextPlayer() {
+        if (isClockwise) {
+            currentPlayerIndex = (currentPlayerIndex + 1) % players.size();
+        } else {
+            currentPlayerIndex = (currentPlayerIndex - 1 + players.size()) % players.size();
+        }
+    }
+    
+    /**
+     * Handles round win scoring and checks for game winner.
+     * 
+     * @param winnerIndex Index of the player who won the round
+     */
+    private void handleRoundWin(int winnerIndex) {
+        Player winner = players.get(winnerIndex);
+        int points = calculateRoundScore(winnerIndex);
+        
+        fireRoundWon(winner, points);
+        
+        // Check for game winner
+        Player gameWinner = checkForGameWinner(TARGET_SCORE);
+        if (gameWinner != null) {
+            fireGameWon(gameWinner);
+        }
+    }
+
+    //EVENT FIRING METHODS
+    
+    /**
+     * Notifies all listeners that the game model has been initialized.
+     */
+    private void fireModelInit() {
+        GameState state = getState();
+        for (GameModelListener listener : listeners) {
+            listener.onModelInit(state);
+        }
+    }
+    
+    /**
+     * Notifies all listeners that the game state has been updated.
+     */
+    private void fireStateUpdated() {
+        GameState state = getState();
+        for (GameModelListener listener : listeners) {
+            listener.onStateUpdated(state);
+        }
+    }
+    
+    /**
+     * Notifies all listeners that the turn has advanced to the next player.
+     * 
+     * @param current The player whose turn it now is
+     */
+    private void fireTurnAdvanced(Player current) {
+        GameState state = getState();
+        for (GameModelListener listener : listeners) {
+            listener.onTurnAdvanced(current, state);
+        }
+    }
+    
+    /**
+     * Notifies all listeners that a player has won a round.
+     * 
+     * @param winner The player who won the round
+     * @param points Points awarded to the winner
+     */
+    private void fireRoundWon(Player winner, int points) {
+        GameState state = getState();
+        for (GameModelListener listener : listeners) {
+            listener.onRoundWon(winner, points, state);
+        }
+    }
+    
+    /**
+     * Notifies all listeners that a player has won the game.
+     * 
+     * @param winner The player who won the game
+     */
+    private void fireGameWon(Player winner) {
+        GameState state = getState();
+        for (GameModelListener listener : listeners) {
+            listener.onGameWon(winner, state);
+        }
+    }
+    
+    /**
+     * Notifies all listeners of an error condition.
+     * 
+     * @param msg Error message
+     */
+    private void fireError(String msg) {
+        for (GameModelListener listener : listeners) {
+            listener.onError(msg);
+        }
+    }
+
+
+
+    public GameState getState()
+    {
+        GameState state = new GameState();
+        state.players = new ArrayList<>(players);
+        state.currentPlayer = players.get(currentPlayerIndex);
+        state.topDiscard = getTopDiscardCard();
+        state.deckSize = deck.size();
+        state.playableIndices = getPlayableIndices();
+        state.clockwise = isClockwise;
+        return state;
+    }
+
+}
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Uno-project\r\nuno project for sysc 3110 group project\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 50f1716e4a7d582b5dcca84e7580a4a9719ee127)
+++ b/README.md	(date 1762721778183)
@@ -1,2 +1,343 @@
-# Uno-project
-uno project for sysc 3110 group project
+# UNO Game Project
+
+## SYSC 3110 - Group Project - Milestone 1
+
+A Java implementation of the classic UNO card game with action cards, special rules, and a complete scoring system.
+
+---
+
+## Table of Contents
+
+- [Project Description](#project-description)
+- [Features](#features)
+- [Project Structure](#project-structure)
+- [How to Run](#how-to-run)
+- [How to Run Tests](#how-to-run-tests)
+- [Game Rules](#game-rules)
+- [Team Contributions](#team-contributions)
+- [Known Issues](#known-issues)
+- [Deliverables](#deliverables)
+- [Documentation](#documentation)
+
+---
+
+## Project Description
+
+This project implements a fully functional UNO card game in Java. Players can play cards, draw from the deck, and compete to reach a target score of 500 points. The game includes all standard UNO cards and special action cards such as Skip, Reverse, Draw One, Wild, and Wild Draw Two.
+
+---
+
+## Features
+
+### Milestone 1
+- **Player Management**: Support for 2-4 players with validation
+- **Card System**: Complete deck of 100 UNO cards (modified from standard 108)
+- **Basic Gameplay**: Card dealing, turn passing, and hand management
+- **Card Visibility**: Display player hands with card indices
+- **Action Cards**: Implementation of Skip, Reverse, Draw One, Wild, and Wild Draw Two cards
+- **Card Placement**: Keyboard input for selecting and playing cards
+- **Card Placement Validation**: Validates card plays according to UNO rules
+- **Resultant State Display**: Shows discard pile and next player's cards after each turn
+- **Scoring System**: Point calculation based on UNO scoring rules
+- **Comprehensive JUnit Tests**: Full test coverage for all game classes
+- **UML Documentation**: Class diagrams and sequence diagrams
+
+---
+
+## Project Structure
+
+```
+Uno-project/
+‚îú‚îÄ‚îÄ uno project/
+‚îÇ   ‚îú‚îÄ‚îÄ src/
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Card.java           # Card representation with colors and values
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Deck.java           # Deck management and initialization
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Player.java         # Player data and hand management
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UnoGame.java        # Main game logic and rules
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Main.java           # Interactive game entry point
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TestMain.java       # Automated testing program
+‚îÇ   ‚îî‚îÄ‚îÄ tests/
+‚îÇ       ‚îú‚îÄ‚îÄ CardTest.java       # JUnit tests for Card class
+‚îÇ       ‚îú‚îÄ‚îÄ DeckTest.java       # JUnit tests for Deck class
+‚îÇ       ‚îú‚îÄ‚îÄ PlayerTest.java     # JUnit tests for Player class
+‚îÇ       ‚îî‚îÄ‚îÄ UnoGameTest.java    # JUnit tests for UnoGame class
+‚îú‚îÄ‚îÄ README.md
+‚îú‚îÄ‚îÄ DataStructures.md           # Data structure documentation
+‚îî‚îÄ‚îÄ LICENSE
+```
+
+---
+
+## How to Run
+
+### Prerequisites
+- Java Development Kit (JDK) 17 or higher
+- IntelliJ IDEA, Eclipse, or any Java IDE
+- JUnit 5 for running tests
+
+### Running the Game
+
+1. Clone the repository:
+```bash
+git clone https://github.com/Nhfaris627/Uno-project.git
+cd Uno-project
+```
+
+2. Open the project in your IDE
+
+3. Run `Main.java` to start the interactive game
+
+4. Follow the console prompts:
+   - Enter number of players (2-4)
+   - Enter player names
+   - Play cards by entering card indices or -1 to draw
+   - Follow special card prompts (color selection for Wild cards)
+
+
+## How to Run Tests
+
+### In IntelliJ IDEA
+1. Ensure the `tests` folder is marked as "Test Sources Root"
+   - Right-click on `tests` folder
+   - Select "Mark Directory as" ‚Üí "Test Sources Root"
+2. Right-click on any test class (CardTest, DeckTest, PlayerTest, UnoGameTest)
+3. Select "Run [TestClassName]"
+
+### From Command Line (with Maven)
+```bash
+mvn test
+```
+
+### From Command Line (with Gradle)
+```bash
+gradle test
+```
+
+---
+
+## Game Rules
+
+### Card Types and Point Values
+- **Number Cards (0-9)**: Face value points
+- **Skip**: 20 points
+- **Reverse**: 20 points (acts as Skip in 2-player games)
+- **Draw One**: 10 points
+- **Wild**: 40 points
+- **Wild Draw Two**: 50 points
+
+### Gameplay
+1. Each player starts with 7 cards
+2. Players must match the color or value of the top discard pile card
+3. Wild cards can be played at any time
+4. If a player cannot play, they must draw from the deck
+5. Drawn cards can be played immediately if valid
+6. First player to empty their hand wins the round
+7. Winner receives points equal to the sum of all opponents' hand values
+8. First player to reach 500 points wins the game
+
+### Action Card Effects
+- **Skip**: Next player's turn is skipped
+- **Reverse**: Direction of play is reversed (acts as Skip in 2-player games)
+- **Draw One**: Next player draws one card and their turn is skipped
+- **Wild**: Player chooses the color to continue play
+- **Wild Draw Two**: Player chooses the color, next player draws two cards and their turn is skipped
+
+---
+
+## Team Contributions
+
+### Bhagya Patel 
+**Milestone 1:**
+- Implemented Card class with enums for colors and values
+- Implemented Deck class with 100-card initialization and shuffle functionality
+- Implemented Player class with hand management and score tracking
+- Implemented basic UnoGame class structure (Player Range, Card Visibility, Pass Turn)
+- Created foundational game setup and initialization logic
+- Documented classes with Javadoc comments
+- **Tasks Completed**: Steps 1-3 (Player Range, Card Visibility, Pass Turn)
+
+### Ivan Arkhipov 
+**Milestone 1:**
+- Implemented action card functionality for all special cards
+  - Draw One card logic with turn skipping
+  - Reverse card logic with direction handling
+  - Skip card implementation
+  - Wild card with color selection prompt
+  - Wild Draw Two card logic
+- Implemented special card handling in game flow
+- Created turn direction management system
+- Handled edge cases for 2-player Reverse functionality
+- **Tasks Completed**: Step 4 (UNO Action Cards - all 5 card types)
+
+### Nicky Fang 
+**Milestone 1:**
+- Implemented keyboard input system for card selection
+- Created interactive card placement interface
+- Implemented card placement validation logic
+  - Match by color validation
+  - Match by value validation
+  - Wild card special case handling
+- Developed playable cards detection system
+- Created user input validation and error handling
+- Implemented card choice validation loop
+- **Tasks Completed**: Steps 5-6 (Card Placement and Validation)
+
+### Faris Hassan 
+**Milestone 1:**
+- Implemented resultant state display system
+- Created scoring system with point calculation
+- Implemented round scoring and game winner detection
+- Developed comprehensive JUnit test suite for all classes
+  - CardTest: Tests for card creation, getters, setters, point values
+  - DeckTest: Tests for deck initialization, shuffling, drawing
+  - PlayerTest: Tests for player management, scoring, hand calculations
+  - UnoGameTest: Tests for game logic, turn management, scoring
+- Created UML class diagrams showing all relationships
+- Created sequence diagrams for key game scenarios
+- Wrote data structure documentation explaining design choices
+- Updated README with complete project documentation
+- Fixed scoring implementation and 2-player Reverse card behavior
+- **Tasks Completed**: Steps 7-10 (Resultant State, Scoring, JUnit Testing, UML Modeling)
+
+---
+
+## Known Issues
+
+### Current Issues
+
+1. **Multiple Rounds Not Implemented**: 
+   - When a round ends (player reaches 0 cards), the game calculates scores but does not start a new round
+   - Players would need to restart the program for a new game
+   - **Workaround**: Game ends after first round completion
+   - **Planned Fix**: Implement round reset and multi-round gameplay in Milestone 2
+
+2. **Deck Size Discrepancy**: 
+   - Current implementation uses 100 cards instead of standard 108 UNO cards
+   - This is due to replacement of DRAW_TWO action cards with DRAW_ONE cards per project requirements
+   - Each color has 2 SKIP, 2 REVERSE instead of 2 SKIP, 2 REVERSE, 2 DRAW_TWO
+   - **Impact**: Minimal - game remains balanced and playable
+
+3. **Scanner Resource Warning**: 
+   - Scanner objects in UnoGame are not explicitly closed
+   - This may cause resource leak warnings in some IDEs
+   - **Reason**: Intentional design to allow continuous gameplay without input stream closure
+   - **Impact**: Negligible in practice for short gaming sessions
+
+4. **Pass Turn Method Limitation**: 
+   - The `passTurn()` method is primarily for testing Steps 1-3 requirements
+   - Does not integrate with the full `playTurn()` interactive system
+   - Simulates playing drawn card to discard pile (not realistic gameplay)
+   - **Workaround**: Use `Main.java` with `playTurn()` for actual gameplay
+   - **Note**: `passTurn()` retained for backward compatibility with early milestone testing
+
+5. **No Deck Reshuffle**: 
+   - When deck runs out of cards, no automatic reshuffling of discard pile
+   - Game continues but players cannot draw new cards
+   - **Workaround**: 100-card deck is usually sufficient for typical games
+   - **Planned Fix**: Implement discard pile reshuffling in future milestone
+
+### Test Limitations
+
+- The `playTurn()` method cannot be easily unit tested due to Scanner keyboard input requirements
+- Private helper methods in UnoGame are not directly tested but are covered through integration testing
+- Display methods (like `displayScores()`, `displayResultantState()`) are not unit tested as they only print to console
+
+### Future Improvements
+
+- Add GUI interface for better user experience
+- Implement AI players for single-player mode
+- Add save/load game functionality
+- Implement multiple rounds with persistent scoring
+- Add game statistics tracking
+- Implement deck reshuffling when empty
+- Add sound effects and animations (GUI version)
+- Support for house rules and custom game modes
+
+---
+
+## Deliverables
+
+### Milestone 1 Requirements (20 marks total)
+
+1. **Player Range (2 marks)**: ‚úÖ Validates 2-4 players, rejects invalid counts
+2. **Card Visibility (1 mark)**: ‚úÖ Displays player hands with indices
+3. **Pass Turn (1 mark)**: ‚úÖ Players can draw cards and pass turns
+4. **Action Cards (3.5 marks)**: ‚úÖ All action cards fully implemented
+   - Draw One (0.5 marks)
+   - Reverse (0.5 marks)
+   - Skip (0.5 marks)
+   - Wild (0.5 marks)
+   - Wild Draw Two (1 mark)
+5. **Card Placement (1 mark)**: ‚úÖ Keyboard input for card selection
+6. **Card Placement Validation (1 mark)**: ‚úÖ Validates plays according to UNO rules
+7. **Resultant State (1 mark)**: ‚úÖ Displays game state after each turn
+8. **Scoring (1 mark)**: ‚úÖ Complete scoring system with point calculation
+9. **JUnit Tests (3 marks)**: ‚úÖ Comprehensive tests for all classes
+10. **UML Modeling (3 marks)**: ‚úÖ Class diagrams, sequence diagrams, data structure documentation
+11. **README and Proper Documentation (3 marks)**: ‚úÖ This file and DataStructures.md
+
+
+**Total: 20/20 marks**
+
+---
+
+## Documentation
+
+### UML Diagrams
+- **Class Diagram**: Located in project root, shows all classes with complete method signatures and relationships (composition, aggregation, association)
+- **Sequence Diagrams**: Two diagrams showing:
+  1. Player plays a valid card (normal turn flow)
+  2. Player wins a round and scoring (game completion flow)
+
+### Data Structures
+- **Documentation**: See `DataStructures.md` for detailed explanation of:
+  - ArrayList usage for cards, players, and indices
+  - Rationale for each data structure choice
+  - Time and space complexity analysis
+  - Trade-offs and alternatives considered
+
+### Test Coverage
+- **CardTest**: 10 tests covering constructors, getters, setters, point values, toString
+- **DeckTest**: 6 tests covering initialization, drawing, shuffling, size checks
+- **PlayerTest**: 10 tests covering player creation, hand management, scoring, calculations
+- **UnoGameTest**: 16 tests covering game creation, turn management, scoring, winner detection
+
+---
+
+## Design Patterns Used
+
+1. **Enumeration Pattern**: Card.Color and Card.Value for type-safe card properties
+2. **Composition**: Card contains Color and Value enums
+3. **Aggregation**: UnoGame manages Players and Deck, Player and Deck manage Cards
+4. **Model-View Separation**: Game logic separated from display methods
+5. **Factory-like Initialization**: Deck automatically creates and shuffles cards on construction
+
+---
+
+## License
+
+This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
+
+---
+
+## Authors
+
+- **Bhagya Patel** - Student ID: 101324150
+- **Ivan Arkhipov** - Student ID: 101310636
+- **Nicky Fang** - Student ID: 101304731
+- **Faris Hassan** - Student ID: 101300683
+
+**Course**: SYSC 3110 - Software Development Project  
+**Institution**: Carleton University  
+**Academic Term**: Fall 2025  
+**Milestone**: 1
+
+---
+
+## Acknowledgments
+
+- UNO is a registered trademark of Mattel, Inc.
+- This project is for educational purposes only
+- Game rules adapted from official UNO rules documentation
+- JUnit 5 testing framework
+- PlantUML for diagram generation
Index: uno project/src/GameModelListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/GameModelListener.java b/uno project/src/GameModelListener.java
new file mode 100644
--- /dev/null	(date 1762721778185)
+++ b/uno project/src/GameModelListener.java	(date 1762721778185)
@@ -0,0 +1,93 @@
+/**
+ *
+ * Listener interface for GameModel events
+ * Implements the observer pattern to notify views and controllers of game state changes
+ * @author Bhagya Patel 101324150
+ *
+ */
+
+public interface GameModelListener {
+
+    /**
+     * Called when the game model is initialized and ready to start.
+     * This is fired after dealing cards and setting up the initial discard pile
+     *
+     * ex.
+     * <pre>
+     *     Public void onModelInit(GameState state){
+     *         view.render(state);
+     *         view.showMessage("Game started! " + state.currentPlayer.getName + "goes first");
+     *     }
+     * </pre>
+     */
+    public void onModelInit(GameState state);
+
+    /**
+     * Called when the game is initialized and ready to start
+     * @param state initial game state
+     */
+    public void onGameInitialized(GameState state);
+
+
+    /**
+     * called when game state changes (played card, drawn, etc...)
+     * @param state updated game state
+     */
+    public void onStateUpdated(GameState state);
+
+    /**
+     * Called when the turn advances to the next player.
+     * This is fired after endTurn() is called or after special card effects that skip players.
+     *
+     * The current parameter provides direct access to the player whose turn it now is,
+     * while the state parameter provides the complete game state.
+     *
+     * Example usage in controller:
+     * <pre>
+     * public void onTurnAdvanced(Player current, GameState state) {
+     *     view.render(state);
+     *     view.showMessage("It's now " + current.getName() + "'s turn");
+     * }
+     * </pre>
+     *
+     * @param current The player whose turn it now is
+     * @param state The current game state
+     */
+    public void onTurnAdvanced(Player current, GameState state);
+
+    /**
+     * called when player wins a round (empty hand)
+     * @param  winner The player who won round
+     * @param pointsAwarded the points awarded to winner
+     * @param state current game state
+     */
+    public void onRoundWon(Player winner, int pointsAwarded, GameState state);
+
+    /**
+     * callled when player wins entire game (reached score)
+     * @param winner The player who won the game
+     * @param state final game state
+     */
+    public void onGameWon(Player winner, GameState state);
+
+    /**
+     * Called when an error occurs during game operations.
+     *
+     * Common error scenarios:
+     * - Invalid card plays (card not playable on current discard)
+     * - Playing out of turn
+     * - Deck exhaustion (no cards left to draw)
+     * - Invalid card index
+     *
+     * Example usage in controller:
+     * <pre>
+     * public void onError(String message) {
+     *     view.showMessage("Error: " + message);
+     * }
+     * </pre>
+     *
+     * @param message A descriptive error message
+     */
+    void onError(String message);
+}
+
Index: uno project/src/GameState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/uno project/src/GameState.java b/uno project/src/GameState.java
new file mode 100644
--- /dev/null	(date 1762721778185)
+++ b/uno project/src/GameState.java	(date 1762721778185)
@@ -0,0 +1,10 @@
+import java.util.*;
+
+public class GameState {
+    public List<Player> players;
+    public Player currentPlayer;
+    public Card topDiscard;
+    public int deckSize;
+    public List<Integer> playableIndices;
+    public boolean clockwise;
+}
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Compiled class file\r\n*.class\r\n\r\n# Log file\r\n*.log\r\n\r\n# BlueJ files\r\n*.ctxt\r\n\r\n# Mobile Tools for Java (J2ME)\r\n.mtj.tmp/\r\n\r\n# Package Files #\r\n*.jar\r\n*.war\r\n*.nar\r\n*.ear\r\n*.zip\r\n*.tar.gz\r\n*.rar\r\n\r\n# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml\r\nhs_err_pid*\r\nreplay_pid*\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision 50f1716e4a7d582b5dcca84e7580a4a9719ee127)
+++ b/.gitignore	(date 1762721778182)
@@ -1,6 +1,6 @@
 # Compiled class file
 *.class
-
+*.xml
 # Log file
 *.log
 
